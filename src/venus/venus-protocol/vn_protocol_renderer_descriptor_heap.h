/* This file is generated by venus-protocol.  See vn_protocol_renderer.h. */

/*
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: MIT
 */

#ifndef VN_PROTOCOL_RENDERER_DESCRIPTOR_HEAP_H
#define VN_PROTOCOL_RENDERER_DESCRIPTOR_HEAP_H

#include "vn_protocol_renderer_structs.h"

#pragma GCC diagnostic push
#if !defined(__clang__) && defined(__GNUC__) && __GNUC__ >= 12
#pragma GCC diagnostic ignored "-Wdangling-pointer"
#endif
#pragma GCC diagnostic ignored "-Wpointer-arith"
#pragma GCC diagnostic ignored "-Wunused-parameter"

/*
 * These structs/unions/commands are not included
 *
 *   vkWriteSamplerDescriptorsEXT
 *   vkWriteResourceDescriptorsEXT
 */

/* struct VkHostAddressRangeEXT */

static inline void
vn_encode_VkHostAddressRangeEXT(struct vn_cs_encoder *enc, const VkHostAddressRangeEXT *val)
{
    vn_encode_size_t(enc, &val->size);
    if (val->address) {
        vn_encode_array_size(enc, val->size);
        vn_encode_blob_array(enc, val->address, val->size);
    } else {
        vn_encode_array_size(enc, 0);
    }
}

static inline void
vn_decode_VkHostAddressRangeEXT_temp(struct vn_cs_decoder *dec, VkHostAddressRangeEXT *val)
{
    vn_decode_size_t(dec, &val->size);
    if (vn_peek_array_size(dec)) {
        const size_t array_size = vn_decode_array_size(dec, val->size);
        val->address = vn_cs_decoder_alloc_temp(dec, array_size);
        if (!val->address) return;
        vn_decode_blob_array(dec, val->address, array_size);
    } else {
        vn_decode_array_size(dec, val->size);
        val->address = NULL;
    }
}

static inline void
vn_decode_VkHostAddressRangeEXT_partial_temp(struct vn_cs_decoder *dec, VkHostAddressRangeEXT *val)
{
    vn_decode_size_t(dec, &val->size);
    if (vn_peek_array_size(dec)) {
        const size_t array_size = vn_decode_array_size(dec, val->size);
        val->address = vn_cs_decoder_alloc_temp(dec, array_size);
        if (!val->address) return;
    } else {
        vn_decode_array_size(dec, val->size);
        val->address = NULL;
    }
}

static inline void
vn_replace_VkHostAddressRangeEXT_handle(VkHostAddressRangeEXT *val)
{
    /* skip val->size */
    /* skip val->address */
}

/* struct VkImageDescriptorInfoEXT chain */

static inline void *
vn_decode_VkImageDescriptorInfoEXT_pnext_temp(struct vn_cs_decoder *dec)
{
    /* no known/supported struct */
    if (vn_decode_simple_pointer(dec))
        vn_cs_decoder_set_fatal(dec);
    return NULL;
}

static inline void
vn_decode_VkImageDescriptorInfoEXT_self_temp(struct vn_cs_decoder *dec, VkImageDescriptorInfoEXT *val)
{
    /* skip val->{sType,pNext} */
    if (vn_decode_simple_pointer(dec)) {
        val->pView = vn_cs_decoder_alloc_temp(dec, sizeof(*val->pView));
        if (!val->pView) return;
        vn_decode_VkImageViewCreateInfo_temp(dec, (VkImageViewCreateInfo *)val->pView);
    } else {
        val->pView = NULL;
        vn_cs_decoder_set_fatal(dec);
    }
    vn_decode_VkImageLayout(dec, &val->layout);
}

static inline void
vn_decode_VkImageDescriptorInfoEXT_temp(struct vn_cs_decoder *dec, VkImageDescriptorInfoEXT *val)
{
    VkStructureType stype;
    vn_decode_VkStructureType(dec, &stype);
    if (stype != VK_STRUCTURE_TYPE_IMAGE_DESCRIPTOR_INFO_EXT)
        vn_cs_decoder_set_fatal(dec);

    val->sType = stype;
    val->pNext = vn_decode_VkImageDescriptorInfoEXT_pnext_temp(dec);
    vn_decode_VkImageDescriptorInfoEXT_self_temp(dec, val);
}

static inline void
vn_replace_VkImageDescriptorInfoEXT_handle_self(VkImageDescriptorInfoEXT *val)
{
    /* skip val->sType */
    /* skip val->pNext */
    if (val->pView)
        vn_replace_VkImageViewCreateInfo_handle((VkImageViewCreateInfo *)val->pView);
    /* skip val->layout */
}

static inline void
vn_replace_VkImageDescriptorInfoEXT_handle(VkImageDescriptorInfoEXT *val)
{
    struct VkBaseOutStructure *pnext = (struct VkBaseOutStructure *)val;

    do {
        switch ((int32_t)pnext->sType) {
        case VK_STRUCTURE_TYPE_IMAGE_DESCRIPTOR_INFO_EXT:
            vn_replace_VkImageDescriptorInfoEXT_handle_self((VkImageDescriptorInfoEXT *)pnext);
            break;
        default:
            /* ignore unknown/unsupported struct */
            break;
        }
        pnext = pnext->pNext;
    } while (pnext);
}

/* struct VkTexelBufferDescriptorInfoEXT chain */

static inline void *
vn_decode_VkTexelBufferDescriptorInfoEXT_pnext_temp(struct vn_cs_decoder *dec)
{
    /* no known/supported struct */
    if (vn_decode_simple_pointer(dec))
        vn_cs_decoder_set_fatal(dec);
    return NULL;
}

static inline void
vn_decode_VkTexelBufferDescriptorInfoEXT_self_temp(struct vn_cs_decoder *dec, VkTexelBufferDescriptorInfoEXT *val)
{
    /* skip val->{sType,pNext} */
    vn_decode_VkFormat(dec, &val->format);
    vn_decode_VkDeviceAddressRangeEXT_temp(dec, &val->addressRange);
}

static inline void
vn_decode_VkTexelBufferDescriptorInfoEXT_temp(struct vn_cs_decoder *dec, VkTexelBufferDescriptorInfoEXT *val)
{
    VkStructureType stype;
    vn_decode_VkStructureType(dec, &stype);
    if (stype != VK_STRUCTURE_TYPE_TEXEL_BUFFER_DESCRIPTOR_INFO_EXT)
        vn_cs_decoder_set_fatal(dec);

    val->sType = stype;
    val->pNext = vn_decode_VkTexelBufferDescriptorInfoEXT_pnext_temp(dec);
    vn_decode_VkTexelBufferDescriptorInfoEXT_self_temp(dec, val);
}

static inline void
vn_replace_VkTexelBufferDescriptorInfoEXT_handle_self(VkTexelBufferDescriptorInfoEXT *val)
{
    /* skip val->sType */
    /* skip val->pNext */
    /* skip val->format */
    vn_replace_VkDeviceAddressRangeEXT_handle(&val->addressRange);
}

static inline void
vn_replace_VkTexelBufferDescriptorInfoEXT_handle(VkTexelBufferDescriptorInfoEXT *val)
{
    struct VkBaseOutStructure *pnext = (struct VkBaseOutStructure *)val;

    do {
        switch ((int32_t)pnext->sType) {
        case VK_STRUCTURE_TYPE_TEXEL_BUFFER_DESCRIPTOR_INFO_EXT:
            vn_replace_VkTexelBufferDescriptorInfoEXT_handle_self((VkTexelBufferDescriptorInfoEXT *)pnext);
            break;
        default:
            /* ignore unknown/unsupported struct */
            break;
        }
        pnext = pnext->pNext;
    } while (pnext);
}

/* struct VkTensorViewCreateInfoARM chain */

static inline void *
vn_decode_VkTensorViewCreateInfoARM_pnext_temp(struct vn_cs_decoder *dec)
{
    /* no known/supported struct */
    if (vn_decode_simple_pointer(dec))
        vn_cs_decoder_set_fatal(dec);
    return NULL;
}

static inline void
vn_decode_VkTensorViewCreateInfoARM_self_temp(struct vn_cs_decoder *dec, VkTensorViewCreateInfoARM *val)
{
    /* skip val->{sType,pNext} */
    vn_decode_VkFlags64(dec, &val->flags);
    vn_decode_VkTensorARM_lookup(dec, &val->tensor);
    vn_decode_VkFormat(dec, &val->format);
}

static inline void
vn_decode_VkTensorViewCreateInfoARM_temp(struct vn_cs_decoder *dec, VkTensorViewCreateInfoARM *val)
{
    VkStructureType stype;
    vn_decode_VkStructureType(dec, &stype);
    if (stype != VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM)
        vn_cs_decoder_set_fatal(dec);

    val->sType = stype;
    val->pNext = vn_decode_VkTensorViewCreateInfoARM_pnext_temp(dec);
    vn_decode_VkTensorViewCreateInfoARM_self_temp(dec, val);
}

static inline void
vn_replace_VkTensorViewCreateInfoARM_handle_self(VkTensorViewCreateInfoARM *val)
{
    /* skip val->sType */
    /* skip val->pNext */
    /* skip val->flags */
    vn_replace_VkTensorARM_handle(&val->tensor);
    /* skip val->format */
}

static inline void
vn_replace_VkTensorViewCreateInfoARM_handle(VkTensorViewCreateInfoARM *val)
{
    struct VkBaseOutStructure *pnext = (struct VkBaseOutStructure *)val;

    do {
        switch ((int32_t)pnext->sType) {
        case VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM:
            vn_replace_VkTensorViewCreateInfoARM_handle_self((VkTensorViewCreateInfoARM *)pnext);
            break;
        default:
            /* ignore unknown/unsupported struct */
            break;
        }
        pnext = pnext->pNext;
    } while (pnext);
}

/* union VkResourceDescriptorDataEXT */

static inline void
vn_decode_VkResourceDescriptorDataEXT_temp(struct vn_cs_decoder *dec, VkResourceDescriptorDataEXT *val)
{
    VkDescriptorType tag;
    vn_decode_VkDescriptorType(dec, &tag);
    switch (tag) {
    case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
        if (vn_decode_simple_pointer(dec)) {
            val->pImage = vn_cs_decoder_alloc_temp(dec, sizeof(*val->pImage));
            if (!val->pImage) return;
            vn_decode_VkImageDescriptorInfoEXT_temp(dec, (VkImageDescriptorInfoEXT *)val->pImage);
        } else {
            val->pImage = NULL;
        }
        break;
    case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:
        if (vn_decode_simple_pointer(dec)) {
            val->pImage = vn_cs_decoder_alloc_temp(dec, sizeof(*val->pImage));
            if (!val->pImage) return;
            vn_decode_VkImageDescriptorInfoEXT_temp(dec, (VkImageDescriptorInfoEXT *)val->pImage);
        } else {
            val->pImage = NULL;
        }
        break;
    case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
        if (vn_decode_simple_pointer(dec)) {
            val->pImage = vn_cs_decoder_alloc_temp(dec, sizeof(*val->pImage));
            if (!val->pImage) return;
            vn_decode_VkImageDescriptorInfoEXT_temp(dec, (VkImageDescriptorInfoEXT *)val->pImage);
        } else {
            val->pImage = NULL;
        }
        break;
    case VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM:
        if (vn_decode_simple_pointer(dec)) {
            val->pImage = vn_cs_decoder_alloc_temp(dec, sizeof(*val->pImage));
            if (!val->pImage) return;
            vn_decode_VkImageDescriptorInfoEXT_temp(dec, (VkImageDescriptorInfoEXT *)val->pImage);
        } else {
            val->pImage = NULL;
        }
        break;
    case VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM:
        if (vn_decode_simple_pointer(dec)) {
            val->pImage = vn_cs_decoder_alloc_temp(dec, sizeof(*val->pImage));
            if (!val->pImage) return;
            vn_decode_VkImageDescriptorInfoEXT_temp(dec, (VkImageDescriptorInfoEXT *)val->pImage);
        } else {
            val->pImage = NULL;
        }
        break;
    case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:
        if (vn_decode_simple_pointer(dec)) {
            val->pTexelBuffer = vn_cs_decoder_alloc_temp(dec, sizeof(*val->pTexelBuffer));
            if (!val->pTexelBuffer) return;
            vn_decode_VkTexelBufferDescriptorInfoEXT_temp(dec, (VkTexelBufferDescriptorInfoEXT *)val->pTexelBuffer);
        } else {
            val->pTexelBuffer = NULL;
        }
        break;
    case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
        if (vn_decode_simple_pointer(dec)) {
            val->pTexelBuffer = vn_cs_decoder_alloc_temp(dec, sizeof(*val->pTexelBuffer));
            if (!val->pTexelBuffer) return;
            vn_decode_VkTexelBufferDescriptorInfoEXT_temp(dec, (VkTexelBufferDescriptorInfoEXT *)val->pTexelBuffer);
        } else {
            val->pTexelBuffer = NULL;
        }
        break;
    case VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR:
        if (vn_decode_simple_pointer(dec)) {
            val->pAddressRange = vn_cs_decoder_alloc_temp(dec, sizeof(*val->pAddressRange));
            if (!val->pAddressRange) return;
            vn_decode_VkDeviceAddressRangeEXT_temp(dec, (VkDeviceAddressRangeEXT *)val->pAddressRange);
        } else {
            val->pAddressRange = NULL;
        }
        break;
    case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:
        if (vn_decode_simple_pointer(dec)) {
            val->pAddressRange = vn_cs_decoder_alloc_temp(dec, sizeof(*val->pAddressRange));
            if (!val->pAddressRange) return;
            vn_decode_VkDeviceAddressRangeEXT_temp(dec, (VkDeviceAddressRangeEXT *)val->pAddressRange);
        } else {
            val->pAddressRange = NULL;
        }
        break;
    case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER:
        if (vn_decode_simple_pointer(dec)) {
            val->pAddressRange = vn_cs_decoder_alloc_temp(dec, sizeof(*val->pAddressRange));
            if (!val->pAddressRange) return;
            vn_decode_VkDeviceAddressRangeEXT_temp(dec, (VkDeviceAddressRangeEXT *)val->pAddressRange);
        } else {
            val->pAddressRange = NULL;
        }
        break;
    case VK_DESCRIPTOR_TYPE_TENSOR_ARM:
        if (vn_decode_simple_pointer(dec)) {
            val->pTensorARM = vn_cs_decoder_alloc_temp(dec, sizeof(*val->pTensorARM));
            if (!val->pTensorARM) return;
            vn_decode_VkTensorViewCreateInfoARM_temp(dec, (VkTensorViewCreateInfoARM *)val->pTensorARM);
        } else {
            val->pTensorARM = NULL;
        }
        break;
    default:
        vn_cs_decoder_set_fatal(dec);
        break;
    }
}

static inline void
vn_replace_VkResourceDescriptorDataEXT_handle(VkResourceDescriptorDataEXT *val, VkDescriptorType tag)
{
    switch (tag) {
    case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
        if (val->pImage)
            vn_replace_VkImageDescriptorInfoEXT_handle((VkImageDescriptorInfoEXT *)val->pImage);
        break;
    case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:
        if (val->pImage)
            vn_replace_VkImageDescriptorInfoEXT_handle((VkImageDescriptorInfoEXT *)val->pImage);
        break;
    case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
        if (val->pImage)
            vn_replace_VkImageDescriptorInfoEXT_handle((VkImageDescriptorInfoEXT *)val->pImage);
        break;
    case VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM:
        if (val->pImage)
            vn_replace_VkImageDescriptorInfoEXT_handle((VkImageDescriptorInfoEXT *)val->pImage);
        break;
    case VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM:
        if (val->pImage)
            vn_replace_VkImageDescriptorInfoEXT_handle((VkImageDescriptorInfoEXT *)val->pImage);
        break;
    case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:
        if (val->pTexelBuffer)
            vn_replace_VkTexelBufferDescriptorInfoEXT_handle((VkTexelBufferDescriptorInfoEXT *)val->pTexelBuffer);
        break;
    case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
        if (val->pTexelBuffer)
            vn_replace_VkTexelBufferDescriptorInfoEXT_handle((VkTexelBufferDescriptorInfoEXT *)val->pTexelBuffer);
        break;
    case VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR:
        if (val->pAddressRange)
            vn_replace_VkDeviceAddressRangeEXT_handle((VkDeviceAddressRangeEXT *)val->pAddressRange);
        break;
    case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:
        if (val->pAddressRange)
            vn_replace_VkDeviceAddressRangeEXT_handle((VkDeviceAddressRangeEXT *)val->pAddressRange);
        break;
    case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER:
        if (val->pAddressRange)
            vn_replace_VkDeviceAddressRangeEXT_handle((VkDeviceAddressRangeEXT *)val->pAddressRange);
        break;
    case VK_DESCRIPTOR_TYPE_TENSOR_ARM:
        if (val->pTensorARM)
            vn_replace_VkTensorViewCreateInfoARM_handle((VkTensorViewCreateInfoARM *)val->pTensorARM);
        break;
    default:
        assert(false);
        break;
    }
}

/* struct VkResourceDescriptorInfoEXT chain */

static inline void *
vn_decode_VkResourceDescriptorInfoEXT_pnext_temp(struct vn_cs_decoder *dec)
{
    /* no known/supported struct */
    if (vn_decode_simple_pointer(dec))
        vn_cs_decoder_set_fatal(dec);
    return NULL;
}

static inline void
vn_decode_VkResourceDescriptorInfoEXT_self_temp(struct vn_cs_decoder *dec, VkResourceDescriptorInfoEXT *val)
{
    /* skip val->{sType,pNext} */
    vn_decode_VkDescriptorType(dec, &val->type);
    vn_decode_VkResourceDescriptorDataEXT_temp(dec, &val->data);
}

static inline void
vn_decode_VkResourceDescriptorInfoEXT_temp(struct vn_cs_decoder *dec, VkResourceDescriptorInfoEXT *val)
{
    VkStructureType stype;
    vn_decode_VkStructureType(dec, &stype);
    if (stype != VK_STRUCTURE_TYPE_RESOURCE_DESCRIPTOR_INFO_EXT)
        vn_cs_decoder_set_fatal(dec);

    val->sType = stype;
    val->pNext = vn_decode_VkResourceDescriptorInfoEXT_pnext_temp(dec);
    vn_decode_VkResourceDescriptorInfoEXT_self_temp(dec, val);
}

static inline void
vn_replace_VkResourceDescriptorInfoEXT_handle_self(VkResourceDescriptorInfoEXT *val)
{
    /* skip val->sType */
    /* skip val->pNext */
    /* skip val->type */
    vn_replace_VkResourceDescriptorDataEXT_handle(&val->data, val->type);
}

static inline void
vn_replace_VkResourceDescriptorInfoEXT_handle(VkResourceDescriptorInfoEXT *val)
{
    struct VkBaseOutStructure *pnext = (struct VkBaseOutStructure *)val;

    do {
        switch ((int32_t)pnext->sType) {
        case VK_STRUCTURE_TYPE_RESOURCE_DESCRIPTOR_INFO_EXT:
            vn_replace_VkResourceDescriptorInfoEXT_handle_self((VkResourceDescriptorInfoEXT *)pnext);
            break;
        default:
            /* ignore unknown/unsupported struct */
            break;
        }
        pnext = pnext->pNext;
    } while (pnext);
}

static inline void vn_decode_vkRegisterCustomBorderColorEXT_args_temp(struct vn_cs_decoder *dec, struct vn_command_vkRegisterCustomBorderColorEXT *args)
{
    vn_decode_VkDevice_lookup(dec, &args->device);
    if (vn_decode_simple_pointer(dec)) {
        args->pBorderColor = vn_cs_decoder_alloc_temp(dec, sizeof(*args->pBorderColor));
        if (!args->pBorderColor) return;
        vn_decode_VkSamplerCustomBorderColorCreateInfoEXT_temp(dec, (VkSamplerCustomBorderColorCreateInfoEXT *)args->pBorderColor);
    } else {
        args->pBorderColor = NULL;
        vn_cs_decoder_set_fatal(dec);
    }
    vn_decode_VkBool32(dec, &args->requestIndex);
    if (vn_decode_simple_pointer(dec)) {
        args->pIndex = vn_cs_decoder_alloc_temp(dec, sizeof(*args->pIndex));
        if (!args->pIndex) return;
        vn_decode_uint32_t(dec, args->pIndex);
    } else {
        args->pIndex = NULL;
        vn_cs_decoder_set_fatal(dec);
    }
}

static inline void vn_replace_vkRegisterCustomBorderColorEXT_args_handle(struct vn_command_vkRegisterCustomBorderColorEXT *args)
{
    vn_replace_VkDevice_handle(&args->device);
    if (args->pBorderColor)
        vn_replace_VkSamplerCustomBorderColorCreateInfoEXT_handle((VkSamplerCustomBorderColorCreateInfoEXT *)args->pBorderColor);
    /* skip args->requestIndex */
    /* skip args->pIndex */
}

static inline void vn_encode_vkRegisterCustomBorderColorEXT_reply(struct vn_cs_encoder *enc, const struct vn_command_vkRegisterCustomBorderColorEXT *args)
{
    vn_encode_VkCommandTypeEXT(enc, &(VkCommandTypeEXT){VK_COMMAND_TYPE_vkRegisterCustomBorderColorEXT_EXT});

    vn_encode_VkResult(enc, &args->ret);
    /* skip args->device */
    /* skip args->pBorderColor */
    /* skip args->requestIndex */
    if (vn_encode_simple_pointer(enc, args->pIndex))
        vn_encode_uint32_t(enc, args->pIndex);
}

static inline void vn_decode_vkUnregisterCustomBorderColorEXT_args_temp(struct vn_cs_decoder *dec, struct vn_command_vkUnregisterCustomBorderColorEXT *args)
{
    vn_decode_VkDevice_lookup(dec, &args->device);
    vn_decode_uint32_t(dec, &args->index);
}

static inline void vn_replace_vkUnregisterCustomBorderColorEXT_args_handle(struct vn_command_vkUnregisterCustomBorderColorEXT *args)
{
    vn_replace_VkDevice_handle(&args->device);
    /* skip args->index */
}

static inline void vn_encode_vkUnregisterCustomBorderColorEXT_reply(struct vn_cs_encoder *enc, const struct vn_command_vkUnregisterCustomBorderColorEXT *args)
{
    vn_encode_VkCommandTypeEXT(enc, &(VkCommandTypeEXT){VK_COMMAND_TYPE_vkUnregisterCustomBorderColorEXT_EXT});

    /* skip args->device */
    /* skip args->index */
}

static inline void vn_decode_vkGetImageOpaqueCaptureDataEXT_args_temp(struct vn_cs_decoder *dec, struct vn_command_vkGetImageOpaqueCaptureDataEXT *args)
{
    vn_decode_VkDevice_lookup(dec, &args->device);
    vn_decode_uint32_t(dec, &args->imageCount);
    if (vn_peek_array_size(dec)) {
        const uint32_t iter_count = vn_decode_array_size(dec, args->imageCount);
        args->pImages = vn_cs_decoder_alloc_temp_array(dec, sizeof(*args->pImages), iter_count);
        if (!args->pImages) return;
        for (uint32_t i = 0; i < iter_count; i++)
            vn_decode_VkImage_lookup(dec, &((VkImage *)args->pImages)[i]);
    } else {
        vn_decode_array_size(dec, args->imageCount);
        args->pImages = NULL;
    }
    if (vn_peek_array_size(dec)) {
        const uint32_t iter_count = vn_decode_array_size(dec, args->imageCount);
        args->pDatas = vn_cs_decoder_alloc_temp_array(dec, sizeof(*args->pDatas), iter_count);
        if (!args->pDatas) return;
        for (uint32_t i = 0; i < iter_count; i++)
            vn_decode_VkHostAddressRangeEXT_partial_temp(dec, &args->pDatas[i]);
    } else {
        vn_decode_array_size(dec, args->imageCount);
        args->pDatas = NULL;
    }
}

static inline void vn_replace_vkGetImageOpaqueCaptureDataEXT_args_handle(struct vn_command_vkGetImageOpaqueCaptureDataEXT *args)
{
    vn_replace_VkDevice_handle(&args->device);
    /* skip args->imageCount */
    if (args->pImages) {
       for (uint32_t i = 0; i < args->imageCount; i++)
            vn_replace_VkImage_handle(&((VkImage *)args->pImages)[i]);
    }
    /* skip args->pDatas */
}

static inline void vn_encode_vkGetImageOpaqueCaptureDataEXT_reply(struct vn_cs_encoder *enc, const struct vn_command_vkGetImageOpaqueCaptureDataEXT *args)
{
    vn_encode_VkCommandTypeEXT(enc, &(VkCommandTypeEXT){VK_COMMAND_TYPE_vkGetImageOpaqueCaptureDataEXT_EXT});

    vn_encode_VkResult(enc, &args->ret);
    /* skip args->device */
    /* skip args->imageCount */
    /* skip args->pImages */
    if (args->pDatas) {
        vn_encode_array_size(enc, args->imageCount);
        for (uint32_t i = 0; i < args->imageCount; i++)
            vn_encode_VkHostAddressRangeEXT(enc, &args->pDatas[i]);
    } else {
        vn_encode_array_size(enc, 0);
    }
}

static inline void vn_decode_vkWriteSamplerDescriptorMESA_args_temp(struct vn_cs_decoder *dec, struct vn_cs_encoder *enc, struct vn_command_vkWriteSamplerDescriptorMESA *args)
{
    const VkCommandTypeEXT cmd_type = VK_COMMAND_TYPE_vkWriteSamplerDescriptorMESA_EXT;
    size_t offset = vn_sizeof_VkCommandTypeEXT(&cmd_type);

    VkResult ret;
    offset += vn_sizeof_VkResult(&ret);
    vn_decode_VkDevice_lookup(dec, &args->device);
    if (vn_decode_simple_pointer(dec)) {
        args->pSampler = vn_cs_decoder_alloc_temp(dec, sizeof(*args->pSampler));
        if (!args->pSampler) return;
        vn_decode_VkSamplerCreateInfo_temp(dec, (VkSamplerCreateInfo *)args->pSampler);
    } else {
        args->pSampler = NULL;
        vn_cs_decoder_set_fatal(dec);
    }
    vn_decode_size_t(dec, &args->dataSize);
    if (vn_peek_array_size(dec)) {
        offset += vn_sizeof_array_size(args->dataSize);
        const size_t array_size = vn_decode_array_size(dec, args->dataSize);
        args->pData = vn_cs_encoder_get_blob_storage(enc, offset, array_size);
        if (!args->pData) return;
        offset += vn_sizeof_blob_array(args->pData, array_size);
    } else {
        vn_decode_array_size(dec, args->dataSize);
        args->pData = NULL;
    }
}

static inline void vn_replace_vkWriteSamplerDescriptorMESA_args_handle(struct vn_command_vkWriteSamplerDescriptorMESA *args)
{
    vn_replace_VkDevice_handle(&args->device);
    if (args->pSampler)
        vn_replace_VkSamplerCreateInfo_handle((VkSamplerCreateInfo *)args->pSampler);
    /* skip args->dataSize */
    /* skip args->pData */
}

static inline void vn_encode_vkWriteSamplerDescriptorMESA_reply(struct vn_cs_encoder *enc, const struct vn_command_vkWriteSamplerDescriptorMESA *args)
{
    vn_encode_VkCommandTypeEXT(enc, &(VkCommandTypeEXT){VK_COMMAND_TYPE_vkWriteSamplerDescriptorMESA_EXT});

    vn_encode_VkResult(enc, &args->ret);
    /* skip args->device */
    /* skip args->pSampler */
    /* skip args->dataSize */
    if (args->pData) {
        vn_encode_array_size(enc, args->dataSize);
        vn_encode_blob_array(enc, args->pData, args->dataSize);
    } else {
        vn_encode_array_size(enc, 0);
    }
}

static inline void vn_decode_vkWriteResourceDescriptorMESA_args_temp(struct vn_cs_decoder *dec, struct vn_cs_encoder *enc, struct vn_command_vkWriteResourceDescriptorMESA *args)
{
    const VkCommandTypeEXT cmd_type = VK_COMMAND_TYPE_vkWriteResourceDescriptorMESA_EXT;
    size_t offset = vn_sizeof_VkCommandTypeEXT(&cmd_type);

    VkResult ret;
    offset += vn_sizeof_VkResult(&ret);
    vn_decode_VkDevice_lookup(dec, &args->device);
    if (vn_decode_simple_pointer(dec)) {
        args->pResource = vn_cs_decoder_alloc_temp(dec, sizeof(*args->pResource));
        if (!args->pResource) return;
        vn_decode_VkResourceDescriptorInfoEXT_temp(dec, (VkResourceDescriptorInfoEXT *)args->pResource);
    } else {
        args->pResource = NULL;
        vn_cs_decoder_set_fatal(dec);
    }
    vn_decode_size_t(dec, &args->dataSize);
    if (vn_peek_array_size(dec)) {
        offset += vn_sizeof_array_size(args->dataSize);
        const size_t array_size = vn_decode_array_size(dec, args->dataSize);
        args->pData = vn_cs_encoder_get_blob_storage(enc, offset, array_size);
        if (!args->pData) return;
        offset += vn_sizeof_blob_array(args->pData, array_size);
    } else {
        vn_decode_array_size(dec, args->dataSize);
        args->pData = NULL;
    }
}

static inline void vn_replace_vkWriteResourceDescriptorMESA_args_handle(struct vn_command_vkWriteResourceDescriptorMESA *args)
{
    vn_replace_VkDevice_handle(&args->device);
    if (args->pResource)
        vn_replace_VkResourceDescriptorInfoEXT_handle((VkResourceDescriptorInfoEXT *)args->pResource);
    /* skip args->dataSize */
    /* skip args->pData */
}

static inline void vn_encode_vkWriteResourceDescriptorMESA_reply(struct vn_cs_encoder *enc, const struct vn_command_vkWriteResourceDescriptorMESA *args)
{
    vn_encode_VkCommandTypeEXT(enc, &(VkCommandTypeEXT){VK_COMMAND_TYPE_vkWriteResourceDescriptorMESA_EXT});

    vn_encode_VkResult(enc, &args->ret);
    /* skip args->device */
    /* skip args->pResource */
    /* skip args->dataSize */
    if (args->pData) {
        vn_encode_array_size(enc, args->dataSize);
        vn_encode_blob_array(enc, args->pData, args->dataSize);
    } else {
        vn_encode_array_size(enc, 0);
    }
}

static inline void vn_dispatch_vkRegisterCustomBorderColorEXT(struct vn_dispatch_context *ctx, VkCommandFlagsEXT flags)
{
    struct vn_command_vkRegisterCustomBorderColorEXT args;

    if (!ctx->dispatch_vkRegisterCustomBorderColorEXT) {
        vn_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vn_decode_vkRegisterCustomBorderColorEXT_args_temp(ctx->decoder, &args);
    if (!args.device) {
        vn_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vn_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_vkRegisterCustomBorderColorEXT(ctx, &args);

#ifdef DEBUG
    if (!vn_cs_decoder_get_fatal(ctx->decoder) && vn_dispatch_should_log_result(args.ret))
        vn_dispatch_debug_log(ctx, "vkRegisterCustomBorderColorEXT returned %d", args.ret);
#endif

    if ((flags & VK_COMMAND_GENERATE_REPLY_BIT_EXT) && !vn_cs_decoder_get_fatal(ctx->decoder)) {
        if (vn_cs_encoder_acquire(ctx->encoder)) {
            vn_encode_vkRegisterCustomBorderColorEXT_reply(ctx->encoder, &args);
            vn_cs_encoder_release(ctx->encoder);
        }
    }

    vn_cs_decoder_reset_temp_pool(ctx->decoder);
}

static inline void vn_dispatch_vkUnregisterCustomBorderColorEXT(struct vn_dispatch_context *ctx, VkCommandFlagsEXT flags)
{
    struct vn_command_vkUnregisterCustomBorderColorEXT args;

    if (!ctx->dispatch_vkUnregisterCustomBorderColorEXT) {
        vn_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vn_decode_vkUnregisterCustomBorderColorEXT_args_temp(ctx->decoder, &args);
    if (!args.device) {
        vn_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vn_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_vkUnregisterCustomBorderColorEXT(ctx, &args);

    if ((flags & VK_COMMAND_GENERATE_REPLY_BIT_EXT) && !vn_cs_decoder_get_fatal(ctx->decoder)) {
        if (vn_cs_encoder_acquire(ctx->encoder)) {
            vn_encode_vkUnregisterCustomBorderColorEXT_reply(ctx->encoder, &args);
            vn_cs_encoder_release(ctx->encoder);
        }
    }

    vn_cs_decoder_reset_temp_pool(ctx->decoder);
}

static inline void vn_dispatch_vkGetImageOpaqueCaptureDataEXT(struct vn_dispatch_context *ctx, VkCommandFlagsEXT flags)
{
    struct vn_command_vkGetImageOpaqueCaptureDataEXT args;

    if (!ctx->dispatch_vkGetImageOpaqueCaptureDataEXT) {
        vn_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vn_decode_vkGetImageOpaqueCaptureDataEXT_args_temp(ctx->decoder, &args);
    if (!args.device) {
        vn_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vn_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_vkGetImageOpaqueCaptureDataEXT(ctx, &args);

#ifdef DEBUG
    if (!vn_cs_decoder_get_fatal(ctx->decoder) && vn_dispatch_should_log_result(args.ret))
        vn_dispatch_debug_log(ctx, "vkGetImageOpaqueCaptureDataEXT returned %d", args.ret);
#endif

    if ((flags & VK_COMMAND_GENERATE_REPLY_BIT_EXT) && !vn_cs_decoder_get_fatal(ctx->decoder)) {
        if (vn_cs_encoder_acquire(ctx->encoder)) {
            vn_encode_vkGetImageOpaqueCaptureDataEXT_reply(ctx->encoder, &args);
            vn_cs_encoder_release(ctx->encoder);
        }
    }

    vn_cs_decoder_reset_temp_pool(ctx->decoder);
}

static inline void vn_dispatch_vkWriteSamplerDescriptorMESA(struct vn_dispatch_context *ctx, VkCommandFlagsEXT flags)
{
    struct vn_command_vkWriteSamplerDescriptorMESA args;

    if (!ctx->dispatch_vkWriteSamplerDescriptorMESA) {
        vn_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (flags & VK_COMMAND_GENERATE_REPLY_BIT_EXT) {
        if (!vn_cs_encoder_acquire(ctx->encoder))
           return;
    }

    vn_decode_vkWriteSamplerDescriptorMESA_args_temp(ctx->decoder, ctx->encoder, &args);
    if (!args.device) {
        vn_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vn_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_vkWriteSamplerDescriptorMESA(ctx, &args);

#ifdef DEBUG
    if (!vn_cs_decoder_get_fatal(ctx->decoder) && vn_dispatch_should_log_result(args.ret))
        vn_dispatch_debug_log(ctx, "vkWriteSamplerDescriptorMESA returned %d", args.ret);
#endif

    if ((flags & VK_COMMAND_GENERATE_REPLY_BIT_EXT) && !vn_cs_decoder_get_fatal(ctx->decoder)) {
        vn_encode_vkWriteSamplerDescriptorMESA_reply(ctx->encoder, &args);
        vn_cs_encoder_release(ctx->encoder);
    }

    vn_cs_decoder_reset_temp_pool(ctx->decoder);
}

static inline void vn_dispatch_vkWriteResourceDescriptorMESA(struct vn_dispatch_context *ctx, VkCommandFlagsEXT flags)
{
    struct vn_command_vkWriteResourceDescriptorMESA args;

    if (!ctx->dispatch_vkWriteResourceDescriptorMESA) {
        vn_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (flags & VK_COMMAND_GENERATE_REPLY_BIT_EXT) {
        if (!vn_cs_encoder_acquire(ctx->encoder))
           return;
    }

    vn_decode_vkWriteResourceDescriptorMESA_args_temp(ctx->decoder, ctx->encoder, &args);
    if (!args.device) {
        vn_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vn_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_vkWriteResourceDescriptorMESA(ctx, &args);

#ifdef DEBUG
    if (!vn_cs_decoder_get_fatal(ctx->decoder) && vn_dispatch_should_log_result(args.ret))
        vn_dispatch_debug_log(ctx, "vkWriteResourceDescriptorMESA returned %d", args.ret);
#endif

    if ((flags & VK_COMMAND_GENERATE_REPLY_BIT_EXT) && !vn_cs_decoder_get_fatal(ctx->decoder)) {
        vn_encode_vkWriteResourceDescriptorMESA_reply(ctx->encoder, &args);
        vn_cs_encoder_release(ctx->encoder);
    }

    vn_cs_decoder_reset_temp_pool(ctx->decoder);
}

#pragma GCC diagnostic pop

#endif /* VN_PROTOCOL_RENDERER_DESCRIPTOR_HEAP_H */
