/* This file is generated by vcl-protocol.  See vcl_protocol_renderer.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#ifndef VCL_PROTOCOL_RENDERER_KERNEL_H
#define VCL_PROTOCOL_RENDERER_KERNEL_H

#include "vcl_protocol_renderer_structs.h"

#pragma GCC diagnostic push
#if !defined(__clang__) && defined(__GNUC__) && __GNUC__ >= 12
#pragma GCC diagnostic ignored "-Wdangling-pointer"
#endif
#pragma GCC diagnostic ignored "-Wpointer-arith"
#pragma GCC diagnostic ignored "-Wunused-parameter"

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clCreateKernelsInProgram_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateKernelsInProgram *args)
{
    vcl_decode_cl_program_lookup(dec, &args->program);
    vcl_decode_cl_uint(dec, &args->num_kernels);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_kernels);
        args->kernels = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->kernels), iter_count);
        if (!args->kernels) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_kernel_temp(dec, &args->kernels[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->kernels = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->num_kernels_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->num_kernels_ret));
        if (!args->num_kernels_ret) return;
    } else {
        args->num_kernels_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clCreateKernelsInProgram_args_handle(struct vcl_command_clCreateKernelsInProgram *args)
{
    vcl_replace_cl_program_handle(&args->program);
    /* skip args->num_kernels */
    /* skip args->kernels */
    /* skip args->num_kernels_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clCreateKernelsInProgram_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateKernelsInProgram *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateKernelsInProgram_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->program */
    /* skip args->num_kernels */
    if (args->kernels) {
        vcl_encode_array_size(enc, args->num_kernels);
        for (cl_uint i = 0; i < args->num_kernels; i++)
            vcl_encode_cl_kernel(enc, &args->kernels[i]);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->num_kernels_ret))
        vcl_encode_cl_uint(enc, args->num_kernels_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clReleaseKernel_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clReleaseKernel *args)
{
    vcl_decode_cl_kernel_lookup(dec, &args->kernel);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clReleaseKernel_args_handle(struct vcl_command_clReleaseKernel *args)
{
    vcl_replace_cl_kernel_handle(&args->kernel);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clReleaseKernel_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clReleaseKernel *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clReleaseKernel_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->kernel */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clSetKernelArg_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clSetKernelArg *args)
{
    vcl_decode_cl_kernel_lookup(dec, &args->kernel);
    vcl_decode_cl_uint(dec, &args->arg_index);
    vcl_decode_size_t(dec, &args->arg_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->arg_size);
        args->arg_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->arg_value) return;
        vcl_decode_blob_array(dec, (void *)args->arg_value, array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->arg_value = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clSetKernelArg_args_handle(struct vcl_command_clSetKernelArg *args)
{
    vcl_replace_cl_kernel_handle(&args->kernel);
    /* skip args->arg_index */
    /* skip args->arg_size */
    /* skip args->arg_value */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clSetKernelArg_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clSetKernelArg *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clSetKernelArg_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->kernel */
    /* skip args->arg_index */
    /* skip args->arg_size */
    /* skip args->arg_value */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_decode_clSetKernelArgSVMPointer_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clSetKernelArgSVMPointer *args)
{
    vcl_decode_cl_kernel_lookup(dec, &args->kernel);
    vcl_decode_cl_uint(dec, &args->arg_index);
    if (vcl_decode_simple_pointer(dec)) {
        vcl_cs_decoder_set_fatal(dec);
    } else {
        args->arg_value = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_replace_clSetKernelArgSVMPointer_args_handle(struct vcl_command_clSetKernelArgSVMPointer *args)
{
    vcl_replace_cl_kernel_handle(&args->kernel);
    /* skip args->arg_index */
    /* skip args->arg_value */
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_encode_clSetKernelArgSVMPointer_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clSetKernelArgSVMPointer *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clSetKernelArgSVMPointer_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->kernel */
    /* skip args->arg_index */
    /* skip args->arg_value */
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_decode_clSetKernelExecInfo_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clSetKernelExecInfo *args)
{
    vcl_decode_cl_kernel_lookup(dec, &args->kernel);
    vcl_decode_cl_kernel_exec_info(dec, &args->param_name);
    vcl_decode_size_t(dec, &args->param_value_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->param_value_size);
        args->param_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->param_value) return;
        vcl_decode_blob_array(dec, (void *)args->param_value, array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->param_value = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_replace_clSetKernelExecInfo_args_handle(struct vcl_command_clSetKernelExecInfo *args)
{
    vcl_replace_cl_kernel_handle(&args->kernel);
    /* skip args->param_name */
    /* skip args->param_value_size */
    /* skip args->param_value */
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_encode_clSetKernelExecInfo_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clSetKernelExecInfo *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clSetKernelExecInfo_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->kernel */
    /* skip args->param_name */
    /* skip args->param_value_size */
    /* skip args->param_value */
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clGetKernelInfo_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetKernelInfo *args)
{
    vcl_decode_cl_kernel_lookup(dec, &args->kernel);
    vcl_decode_cl_kernel_info(dec, &args->param_name);
    vcl_decode_size_t(dec, &args->param_value_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->param_value_size);
        args->param_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->param_value) return;
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->param_value = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->param_value_size_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->param_value_size_ret));
        if (!args->param_value_size_ret) return;
    } else {
        args->param_value_size_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clGetKernelInfo_args_handle(struct vcl_command_clGetKernelInfo *args)
{
    vcl_replace_cl_kernel_handle(&args->kernel);
    /* skip args->param_name */
    /* skip args->param_value_size */
    /* skip args->param_value */
    /* skip args->param_value_size_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clGetKernelInfo_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetKernelInfo *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetKernelInfo_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->kernel */
    /* skip args->param_name */
    /* skip args->param_value_size */
    if (args->param_value) {
        vcl_encode_array_size(enc, args->param_value_size);
        vcl_encode_blob_array(enc, args->param_value, args->param_value_size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->param_value_size_ret))
        vcl_encode_size_t(enc, args->param_value_size_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_decode_clGetKernelArgInfo_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetKernelArgInfo *args)
{
    vcl_decode_cl_kernel_lookup(dec, &args->kernel);
    vcl_decode_cl_uint(dec, &args->arg_index);
    vcl_decode_cl_kernel_arg_info(dec, &args->param_name);
    vcl_decode_size_t(dec, &args->param_value_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->param_value_size);
        args->param_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->param_value) return;
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->param_value = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->param_value_size_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->param_value_size_ret));
        if (!args->param_value_size_ret) return;
    } else {
        args->param_value_size_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_replace_clGetKernelArgInfo_args_handle(struct vcl_command_clGetKernelArgInfo *args)
{
    vcl_replace_cl_kernel_handle(&args->kernel);
    /* skip args->arg_index */
    /* skip args->param_name */
    /* skip args->param_value_size */
    /* skip args->param_value */
    /* skip args->param_value_size_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_encode_clGetKernelArgInfo_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetKernelArgInfo *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetKernelArgInfo_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->kernel */
    /* skip args->arg_index */
    /* skip args->param_name */
    /* skip args->param_value_size */
    if (args->param_value) {
        vcl_encode_array_size(enc, args->param_value_size);
        vcl_encode_blob_array(enc, args->param_value, args->param_value_size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->param_value_size_ret))
        vcl_encode_size_t(enc, args->param_value_size_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clGetKernelWorkGroupInfo_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetKernelWorkGroupInfo *args)
{
    vcl_decode_cl_kernel_lookup(dec, &args->kernel);
    vcl_decode_cl_device_id_lookup(dec, &args->device);
    vcl_decode_cl_kernel_work_group_info(dec, &args->param_name);
    vcl_decode_size_t(dec, &args->param_value_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->param_value_size);
        args->param_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->param_value) return;
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->param_value = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->param_value_size_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->param_value_size_ret));
        if (!args->param_value_size_ret) return;
    } else {
        args->param_value_size_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clGetKernelWorkGroupInfo_args_handle(struct vcl_command_clGetKernelWorkGroupInfo *args)
{
    vcl_replace_cl_kernel_handle(&args->kernel);
    vcl_replace_cl_device_id_handle(&args->device);
    /* skip args->param_name */
    /* skip args->param_value_size */
    /* skip args->param_value */
    /* skip args->param_value_size_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clGetKernelWorkGroupInfo_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetKernelWorkGroupInfo *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetKernelWorkGroupInfo_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->kernel */
    /* skip args->device */
    /* skip args->param_name */
    /* skip args->param_value_size */
    if (args->param_value) {
        vcl_encode_array_size(enc, args->param_value_size);
        vcl_encode_blob_array(enc, args->param_value, args->param_value_size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->param_value_size_ret))
        vcl_encode_size_t(enc, args->param_value_size_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_decode_clGetKernelSubGroupInfo_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetKernelSubGroupInfo *args)
{
    vcl_decode_cl_kernel_lookup(dec, &args->kernel);
    vcl_decode_cl_device_id_lookup(dec, &args->device);
    vcl_decode_cl_kernel_sub_group_info(dec, &args->param_name);
    vcl_decode_size_t(dec, &args->input_value_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->input_value_size);
        args->input_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->input_value) return;
        vcl_decode_blob_array(dec, (void *)args->input_value, array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->input_value = NULL;
    }
    vcl_decode_size_t(dec, &args->param_value_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->param_value_size);
        args->param_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->param_value) return;
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->param_value = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->param_value_size_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->param_value_size_ret));
        if (!args->param_value_size_ret) return;
    } else {
        args->param_value_size_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_replace_clGetKernelSubGroupInfo_args_handle(struct vcl_command_clGetKernelSubGroupInfo *args)
{
    vcl_replace_cl_kernel_handle(&args->kernel);
    vcl_replace_cl_device_id_handle(&args->device);
    /* skip args->param_name */
    /* skip args->input_value_size */
    /* skip args->input_value */
    /* skip args->param_value_size */
    /* skip args->param_value */
    /* skip args->param_value_size_ret */
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_encode_clGetKernelSubGroupInfo_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetKernelSubGroupInfo *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetKernelSubGroupInfo_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->kernel */
    /* skip args->device */
    /* skip args->param_name */
    /* skip args->input_value_size */
    /* skip args->input_value */
    /* skip args->param_value_size */
    if (args->param_value) {
        vcl_encode_array_size(enc, args->param_value_size);
        vcl_encode_blob_array(enc, args->param_value, args->param_value_size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->param_value_size_ret))
        vcl_encode_size_t(enc, args->param_value_size_ret);
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clEnqueueNativeKernel_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueNativeKernel *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_size_t(dec, &args->cb_args);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->cb_args);
        args->args = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->args) return;
    } else {
        vcl_decode_array_size(dec, args->cb_args);
        args->args = NULL;
    }
    vcl_decode_cl_uint(dec, &args->num_mem_objects);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_mem_objects);
        args->mem_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->mem_list), iter_count);
        if (!args->mem_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_mem_lookup(dec, &((cl_mem *)args->mem_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->mem_list = NULL;
    }
    if (vcl_peek_array_size(dec)) {
        vcl_cs_decoder_set_fatal(dec);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->args_mem_loc = NULL;
    }
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clEnqueueNativeKernel_args_handle(struct vcl_command_clEnqueueNativeKernel *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    /* skip args->cb_args */
    /* skip args->args */
    /* skip args->num_mem_objects */
    if (args->mem_list) {
       for (cl_uint i = 0; i < args->num_mem_objects; i++)
            vcl_replace_cl_mem_handle(&((cl_mem *)args->mem_list)[i]);
    }
    /* skip args->args_mem_loc */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clEnqueueNativeKernel_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueNativeKernel *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueNativeKernel_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->cb_args */
    if (args->args) {
        vcl_encode_array_size(enc, args->cb_args);
        vcl_encode_blob_array(enc, args->args, args->cb_args);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    /* skip args->num_mem_objects */
    /* skip args->mem_list */
    /* skip args->args_mem_loc */
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
static inline void vcl_decode_clEnqueueTask_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueTask *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_kernel_lookup(dec, &args->kernel);
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
static inline void vcl_replace_clEnqueueTask_args_handle(struct vcl_command_clEnqueueTask *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    vcl_replace_cl_kernel_handle(&args->kernel);
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
static inline void vcl_encode_clEnqueueTask_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueTask *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueTask_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->kernel */
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clCreateKernelMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateKernelMESA *args)
{
    vcl_decode_cl_program_lookup(dec, &args->program);
    if (vcl_peek_array_size(dec)) {
        const size_t null_terminated_array_size = vcl_decode_array_size_unchecked(dec);
        args->kernel_name = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->kernel_name), null_terminated_array_size);
        if (!args->kernel_name) return;
        vcl_decode_char_array(dec, (char *)args->kernel_name, null_terminated_array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->kernel_name = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->kernel = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->kernel));
        if (!args->kernel) return;
        vcl_decode_cl_kernel_temp(dec, args->kernel);
    } else {
        args->kernel = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clCreateKernelMESA_args_handle(struct vcl_command_clCreateKernelMESA *args)
{
    vcl_replace_cl_program_handle(&args->program);
    /* skip args->kernel_name */
    /* skip args->kernel */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clCreateKernelMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateKernelMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateKernelMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->program */
    /* skip args->kernel_name */
    if (vcl_encode_simple_pointer(enc, args->kernel))
        vcl_encode_cl_kernel(enc, args->kernel);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_decode_clCloneKernelMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCloneKernelMESA *args)
{
    vcl_decode_cl_kernel_lookup(dec, &args->source_kernel);
    if (vcl_decode_simple_pointer(dec)) {
        args->kernel = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->kernel));
        if (!args->kernel) return;
        vcl_decode_cl_kernel_temp(dec, args->kernel);
    } else {
        args->kernel = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_replace_clCloneKernelMESA_args_handle(struct vcl_command_clCloneKernelMESA *args)
{
    vcl_replace_cl_kernel_handle(&args->source_kernel);
    /* skip args->kernel */
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_encode_clCloneKernelMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCloneKernelMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCloneKernelMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->source_kernel */
    if (vcl_encode_simple_pointer(enc, args->kernel))
        vcl_encode_cl_kernel(enc, args->kernel);
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clEnqueueNDRangeKernelMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueNDRangeKernelMESA *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_kernel_lookup(dec, &args->kernel);
    vcl_decode_cl_uint(dec, &args->work_dim);
    vcl_decode_cl_uint(dec, &args->global_work_offset_dim);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->global_work_offset_dim);
        args->global_work_offset = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->global_work_offset), array_size);
        if (!args->global_work_offset) return;
        vcl_decode_size_t_array(dec, (size_t *)args->global_work_offset, array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->global_work_offset = NULL;
    }
    vcl_decode_cl_uint(dec, &args->global_work_size_dim);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->global_work_size_dim);
        args->global_work_size = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->global_work_size), array_size);
        if (!args->global_work_size) return;
        vcl_decode_size_t_array(dec, (size_t *)args->global_work_size, array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->global_work_size = NULL;
    }
    vcl_decode_cl_uint(dec, &args->local_work_size_dim);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->local_work_size_dim);
        args->local_work_size = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->local_work_size), array_size);
        if (!args->local_work_size) return;
        vcl_decode_size_t_array(dec, (size_t *)args->local_work_size, array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->local_work_size = NULL;
    }
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clEnqueueNDRangeKernelMESA_args_handle(struct vcl_command_clEnqueueNDRangeKernelMESA *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    vcl_replace_cl_kernel_handle(&args->kernel);
    /* skip args->work_dim */
    /* skip args->global_work_offset_dim */
    /* skip args->global_work_offset */
    /* skip args->global_work_size_dim */
    /* skip args->global_work_size */
    /* skip args->local_work_size_dim */
    /* skip args->local_work_size */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clEnqueueNDRangeKernelMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueNDRangeKernelMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueNDRangeKernelMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->kernel */
    /* skip args->work_dim */
    /* skip args->global_work_offset_dim */
    /* skip args->global_work_offset */
    /* skip args->global_work_size_dim */
    /* skip args->global_work_size */
    /* skip args->local_work_size_dim */
    /* skip args->local_work_size */
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0


static inline void vcl_dispatch_clCreateKernelsInProgram(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clCreateKernelsInProgram args;

    if (!ctx->dispatch_clCreateKernelsInProgram) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateKernelsInProgram_args_temp(ctx->decoder, &args);
    if (!args.program) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateKernelsInProgram(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateKernelsInProgram returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateKernelsInProgram_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clCreateKernelsInProgram");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clReleaseKernel(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clReleaseKernel args;

    if (!ctx->dispatch_clReleaseKernel) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clReleaseKernel_args_temp(ctx->decoder, &args);
    if (!args.kernel) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clReleaseKernel(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clReleaseKernel returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clReleaseKernel_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clReleaseKernel");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clSetKernelArg(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clSetKernelArg args;

    if (!ctx->dispatch_clSetKernelArg) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clSetKernelArg_args_temp(ctx->decoder, &args);
    if (!args.kernel) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clSetKernelArg(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clSetKernelArg returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clSetKernelArg_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clSetKernelArg");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clSetKernelArgSVMPointer(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_2_0
    struct vcl_command_clSetKernelArgSVMPointer args;

    if (!ctx->dispatch_clSetKernelArgSVMPointer) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clSetKernelArgSVMPointer_args_temp(ctx->decoder, &args);
    if (!args.kernel) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clSetKernelArgSVMPointer(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clSetKernelArgSVMPointer returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clSetKernelArgSVMPointer_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_2_0 not available for clSetKernelArgSVMPointer");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_2_0
}


static inline void vcl_dispatch_clSetKernelExecInfo(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_2_0
    struct vcl_command_clSetKernelExecInfo args;

    if (!ctx->dispatch_clSetKernelExecInfo) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clSetKernelExecInfo_args_temp(ctx->decoder, &args);
    if (!args.kernel) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clSetKernelExecInfo(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clSetKernelExecInfo returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clSetKernelExecInfo_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_2_0 not available for clSetKernelExecInfo");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_2_0
}


static inline void vcl_dispatch_clGetKernelInfo(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clGetKernelInfo args;

    if (!ctx->dispatch_clGetKernelInfo) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetKernelInfo_args_temp(ctx->decoder, &args);
    if (!args.kernel) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetKernelInfo(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetKernelInfo returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetKernelInfo_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clGetKernelInfo");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clGetKernelArgInfo(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2
    struct vcl_command_clGetKernelArgInfo args;

    if (!ctx->dispatch_clGetKernelArgInfo) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetKernelArgInfo_args_temp(ctx->decoder, &args);
    if (!args.kernel) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetKernelArgInfo(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetKernelArgInfo returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetKernelArgInfo_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2 not available for clGetKernelArgInfo");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2
}


static inline void vcl_dispatch_clGetKernelWorkGroupInfo(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clGetKernelWorkGroupInfo args;

    if (!ctx->dispatch_clGetKernelWorkGroupInfo) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetKernelWorkGroupInfo_args_temp(ctx->decoder, &args);
    if (!args.kernel) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetKernelWorkGroupInfo(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetKernelWorkGroupInfo returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetKernelWorkGroupInfo_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clGetKernelWorkGroupInfo");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clGetKernelSubGroupInfo(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_2_1
    struct vcl_command_clGetKernelSubGroupInfo args;

    if (!ctx->dispatch_clGetKernelSubGroupInfo) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetKernelSubGroupInfo_args_temp(ctx->decoder, &args);
    if (!args.kernel) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetKernelSubGroupInfo(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetKernelSubGroupInfo returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetKernelSubGroupInfo_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_2_1 not available for clGetKernelSubGroupInfo");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_2_1
}


static inline void vcl_dispatch_clEnqueueNativeKernel(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clEnqueueNativeKernel args;

    if (!ctx->dispatch_clEnqueueNativeKernel) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueNativeKernel_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueNativeKernel(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueNativeKernel returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueNativeKernel_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clEnqueueNativeKernel");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clEnqueueTask(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
    struct vcl_command_clEnqueueTask args;

    if (!ctx->dispatch_clEnqueueTask) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueTask_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueTask(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueTask returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueTask_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2_DEPRECATED not available for clEnqueueTask");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED
}


static inline void vcl_dispatch_clCreateKernelMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clCreateKernelMESA args;

    if (!ctx->dispatch_clCreateKernelMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateKernelMESA_args_temp(ctx->decoder, &args);
    if (!args.program) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateKernelMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateKernelMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateKernelMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clCreateKernelMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clCloneKernelMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_2_1
    struct vcl_command_clCloneKernelMESA args;

    if (!ctx->dispatch_clCloneKernelMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCloneKernelMESA_args_temp(ctx->decoder, &args);
    if (!args.source_kernel) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCloneKernelMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCloneKernelMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCloneKernelMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_2_1 not available for clCloneKernelMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_2_1
}


static inline void vcl_dispatch_clEnqueueNDRangeKernelMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clEnqueueNDRangeKernelMESA args;

    if (!ctx->dispatch_clEnqueueNDRangeKernelMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueNDRangeKernelMESA_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueNDRangeKernelMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueNDRangeKernelMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueNDRangeKernelMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clEnqueueNDRangeKernelMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}

#pragma GCC diagnostic pop

#endif /* VCL_PROTOCOL_RENDERER_KERNEL_H */
