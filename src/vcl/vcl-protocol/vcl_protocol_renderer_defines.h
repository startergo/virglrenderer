/* This file is generated by vcl-protocol.  See vcl_protocol_renderer.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#ifndef VCL_PROTOCOL_RENDERER_DEFINES_H
#define VCL_PROTOCOL_RENDERER_DEFINES_H

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "vcl_cl.h"

#include "vcl_protocol_renderer_cs.h"
#include "vcl_protocol_renderer_func_ptrs.h"

typedef enum cl_command_type_ext {
    CL_COMMAND_TYPE_clGetPlatformIDs_EXT = 0,
    CL_COMMAND_TYPE_clGetPlatformInfo_EXT = 1,
    CL_COMMAND_TYPE_clGetDeviceIDs_EXT = 2,
    CL_COMMAND_TYPE_clGetDeviceInfo_EXT = 3,
    CL_COMMAND_TYPE_clCreateSubDevices_EXT = 4,
    CL_COMMAND_TYPE_clRetainDevice_EXT = 5,
    CL_COMMAND_TYPE_clReleaseDevice_EXT = 6,
    CL_COMMAND_TYPE_clSetDefaultDeviceCommandQueue_EXT = 7,
    CL_COMMAND_TYPE_clGetDeviceAndHostTimer_EXT = 8,
    CL_COMMAND_TYPE_clGetHostTimer_EXT = 9,
    CL_COMMAND_TYPE_clCreateContext_EXT = 10,
    CL_COMMAND_TYPE_clCreateContextFromType_EXT = 11,
    CL_COMMAND_TYPE_clRetainContext_EXT = 12,
    CL_COMMAND_TYPE_clReleaseContext_EXT = 13,
    CL_COMMAND_TYPE_clGetContextInfo_EXT = 14,
    CL_COMMAND_TYPE_clSetContextDestructorCallback_EXT = 15,
    CL_COMMAND_TYPE_clCreateCommandQueueWithProperties_EXT = 16,
    CL_COMMAND_TYPE_clRetainCommandQueue_EXT = 17,
    CL_COMMAND_TYPE_clReleaseCommandQueue_EXT = 18,
    CL_COMMAND_TYPE_clGetCommandQueueInfo_EXT = 19,
    CL_COMMAND_TYPE_clCreateBuffer_EXT = 20,
    CL_COMMAND_TYPE_clCreateBufferWithProperties_EXT = 21,
    CL_COMMAND_TYPE_clCreateSubBuffer_EXT = 22,
    CL_COMMAND_TYPE_clCreateImage_EXT = 23,
    CL_COMMAND_TYPE_clCreateImageWithProperties_EXT = 24,
    CL_COMMAND_TYPE_clCreatePipe_EXT = 25,
    CL_COMMAND_TYPE_clRetainMemObject_EXT = 26,
    CL_COMMAND_TYPE_clReleaseMemObject_EXT = 27,
    CL_COMMAND_TYPE_clGetSupportedImageFormats_EXT = 28,
    CL_COMMAND_TYPE_clGetMemObjectInfo_EXT = 29,
    CL_COMMAND_TYPE_clGetImageInfo_EXT = 30,
    CL_COMMAND_TYPE_clGetPipeInfo_EXT = 31,
    CL_COMMAND_TYPE_clSetMemObjectDestructorCallback_EXT = 32,
    CL_COMMAND_TYPE_clSVMAlloc_EXT = 33,
    CL_COMMAND_TYPE_clSVMFree_EXT = 34,
    CL_COMMAND_TYPE_clCreateSamplerWithProperties_EXT = 35,
    CL_COMMAND_TYPE_clRetainSampler_EXT = 36,
    CL_COMMAND_TYPE_clReleaseSampler_EXT = 37,
    CL_COMMAND_TYPE_clGetSamplerInfo_EXT = 38,
    CL_COMMAND_TYPE_clCreateProgramWithSource_EXT = 39,
    CL_COMMAND_TYPE_clCreateProgramWithBinary_EXT = 40,
    CL_COMMAND_TYPE_clCreateProgramWithBuiltInKernels_EXT = 41,
    CL_COMMAND_TYPE_clCreateProgramWithIL_EXT = 42,
    CL_COMMAND_TYPE_clRetainProgram_EXT = 43,
    CL_COMMAND_TYPE_clReleaseProgram_EXT = 44,
    CL_COMMAND_TYPE_clBuildProgram_EXT = 45,
    CL_COMMAND_TYPE_clCompileProgram_EXT = 46,
    CL_COMMAND_TYPE_clLinkProgram_EXT = 47,
    CL_COMMAND_TYPE_clSetProgramReleaseCallback_EXT = 48,
    CL_COMMAND_TYPE_clSetProgramSpecializationConstant_EXT = 49,
    CL_COMMAND_TYPE_clUnloadPlatformCompiler_EXT = 50,
    CL_COMMAND_TYPE_clGetProgramInfo_EXT = 51,
    CL_COMMAND_TYPE_clGetProgramBuildInfo_EXT = 52,
    CL_COMMAND_TYPE_clCreateKernel_EXT = 53,
    CL_COMMAND_TYPE_clCreateKernelsInProgram_EXT = 54,
    CL_COMMAND_TYPE_clCloneKernel_EXT = 55,
    CL_COMMAND_TYPE_clRetainKernel_EXT = 56,
    CL_COMMAND_TYPE_clReleaseKernel_EXT = 57,
    CL_COMMAND_TYPE_clSetKernelArg_EXT = 58,
    CL_COMMAND_TYPE_clSetKernelArgSVMPointer_EXT = 59,
    CL_COMMAND_TYPE_clSetKernelExecInfo_EXT = 60,
    CL_COMMAND_TYPE_clGetKernelInfo_EXT = 61,
    CL_COMMAND_TYPE_clGetKernelArgInfo_EXT = 62,
    CL_COMMAND_TYPE_clGetKernelWorkGroupInfo_EXT = 63,
    CL_COMMAND_TYPE_clGetKernelSubGroupInfo_EXT = 64,
    CL_COMMAND_TYPE_clWaitForEvents_EXT = 65,
    CL_COMMAND_TYPE_clGetEventInfo_EXT = 66,
    CL_COMMAND_TYPE_clCreateUserEvent_EXT = 67,
    CL_COMMAND_TYPE_clRetainEvent_EXT = 68,
    CL_COMMAND_TYPE_clReleaseEvent_EXT = 69,
    CL_COMMAND_TYPE_clSetUserEventStatus_EXT = 70,
    CL_COMMAND_TYPE_clSetEventCallback_EXT = 71,
    CL_COMMAND_TYPE_clGetEventProfilingInfo_EXT = 72,
    CL_COMMAND_TYPE_clFlush_EXT = 73,
    CL_COMMAND_TYPE_clFinish_EXT = 74,
    CL_COMMAND_TYPE_clEnqueueReadBuffer_EXT = 75,
    CL_COMMAND_TYPE_clEnqueueReadBufferRect_EXT = 76,
    CL_COMMAND_TYPE_clEnqueueWriteBuffer_EXT = 77,
    CL_COMMAND_TYPE_clEnqueueWriteBufferRect_EXT = 78,
    CL_COMMAND_TYPE_clEnqueueFillBuffer_EXT = 79,
    CL_COMMAND_TYPE_clEnqueueCopyBuffer_EXT = 80,
    CL_COMMAND_TYPE_clEnqueueCopyBufferRect_EXT = 81,
    CL_COMMAND_TYPE_clEnqueueReadImage_EXT = 82,
    CL_COMMAND_TYPE_clEnqueueWriteImage_EXT = 83,
    CL_COMMAND_TYPE_clEnqueueFillImage_EXT = 84,
    CL_COMMAND_TYPE_clEnqueueCopyImage_EXT = 85,
    CL_COMMAND_TYPE_clEnqueueCopyImageToBuffer_EXT = 86,
    CL_COMMAND_TYPE_clEnqueueCopyBufferToImage_EXT = 87,
    CL_COMMAND_TYPE_clEnqueueMapBuffer_EXT = 88,
    CL_COMMAND_TYPE_clEnqueueMapImage_EXT = 89,
    CL_COMMAND_TYPE_clEnqueueUnmapMemObject_EXT = 90,
    CL_COMMAND_TYPE_clEnqueueMigrateMemObjects_EXT = 91,
    CL_COMMAND_TYPE_clEnqueueNDRangeKernel_EXT = 92,
    CL_COMMAND_TYPE_clEnqueueNativeKernel_EXT = 93,
    CL_COMMAND_TYPE_clEnqueueMarkerWithWaitList_EXT = 94,
    CL_COMMAND_TYPE_clEnqueueBarrierWithWaitList_EXT = 95,
    CL_COMMAND_TYPE_clEnqueueSVMFree_EXT = 96,
    CL_COMMAND_TYPE_clEnqueueSVMMemcpy_EXT = 97,
    CL_COMMAND_TYPE_clEnqueueSVMMemFill_EXT = 98,
    CL_COMMAND_TYPE_clEnqueueSVMMap_EXT = 99,
    CL_COMMAND_TYPE_clEnqueueSVMUnmap_EXT = 100,
    CL_COMMAND_TYPE_clEnqueueSVMMigrateMem_EXT = 101,
    CL_COMMAND_TYPE_clGetExtensionFunctionAddressForPlatform_EXT = 102,
    CL_COMMAND_TYPE_clSetCommandQueueProperty_EXT = 103,
    CL_COMMAND_TYPE_clCreateImage2D_EXT = 104,
    CL_COMMAND_TYPE_clCreateImage3D_EXT = 105,
    CL_COMMAND_TYPE_clEnqueueMarker_EXT = 106,
    CL_COMMAND_TYPE_clEnqueueWaitForEvents_EXT = 107,
    CL_COMMAND_TYPE_clEnqueueBarrier_EXT = 108,
    CL_COMMAND_TYPE_clUnloadCompiler_EXT = 109,
    CL_COMMAND_TYPE_clGetExtensionFunctionAddress_EXT = 110,
    CL_COMMAND_TYPE_clCreateCommandQueue_EXT = 111,
    CL_COMMAND_TYPE_clCreateSampler_EXT = 112,
    CL_COMMAND_TYPE_clEnqueueTask_EXT = 113,
    CL_COMMAND_TYPE_clEnqueueNDRangeKernelMESA_EXT = 229,
    CL_COMMAND_TYPE_clEnqueueMapImageMESA_EXT = 230,
    CL_COMMAND_TYPE_clEnqueueUnmapMemObjectMESA_EXT = 231,
    CL_COMMAND_TYPE_clEnqueueMapBufferMESA_EXT = 232,
    CL_COMMAND_TYPE_clEnqueueReadImageMESA_EXT = 233,
    CL_COMMAND_TYPE_clEnqueueWriteImageMESA_EXT = 234,
    CL_COMMAND_TYPE_clEnqueueFillImageMESA_EXT = 235,
    CL_COMMAND_TYPE_clCreateImageMESA_EXT = 236,
    CL_COMMAND_TYPE_clCreateImageWithPropertiesMESA_EXT = 237,
    CL_COMMAND_TYPE_clCreateSubBufferMESA_EXT = 238,
    CL_COMMAND_TYPE_clCreateImage3DMESA_EXT = 239,
    CL_COMMAND_TYPE_clCreateSamplerWithPropertiesMESA_EXT = 240,
    CL_COMMAND_TYPE_clCreateSamplerMESA_EXT = 241,
    CL_COMMAND_TYPE_clLinkProgramMESA_EXT = 242,
    CL_COMMAND_TYPE_clCreateProgramWithILMESA_EXT = 243,
    CL_COMMAND_TYPE_clCreateProgramWithBinaryMESA_EXT = 244,
    CL_COMMAND_TYPE_clCreateProgramWithSourceMESA_EXT = 245,
    CL_COMMAND_TYPE_clCreateKernelMESA_EXT = 246,
    CL_COMMAND_TYPE_clCloneKernelMESA_EXT = 247,
    CL_COMMAND_TYPE_clCreateImage2DMESA_EXT = 248,
    CL_COMMAND_TYPE_clCreateBufferMESA_EXT = 249,
    CL_COMMAND_TYPE_clCreateBufferWithPropertiesMESA_EXT = 250,
    CL_COMMAND_TYPE_clCreateUserEventMESA_EXT = 251,
    CL_COMMAND_TYPE_clCreateContextMESA_EXT = 252,
    CL_COMMAND_TYPE_clCreateCommandQueueMESA_EXT = 253,
    CL_COMMAND_TYPE_clCreateCommandQueueWithPropertiesMESA_EXT = 254,
    CL_COMMAND_TYPE_clSetReplyBufferMESA_EXT = 255,
} cl_command_type_ext;

typedef enum cl_command_flag_bits_ext {
    Empty = 0x00000000,
    CL_COMMAND_GENERATE_REPLY_BIT_EXT = 0x00000001,
} cl_command_flag_bits_ext;

typedef uint32_t cl_command_flags_ext;

struct vcl_command_clGetPlatformIDs {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_uint num_entries;
    cl_platform_id* platforms;
    cl_uint* num_platforms;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clGetPlatformInfo {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_platform_id platform;
    cl_platform_info param_name;
    size_t param_value_size;
    void* param_value;
    size_t* param_value_size_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clGetDeviceIDs {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_platform_id platform;
    cl_device_type device_type;
    cl_uint num_entries;
    cl_device_id* devices;
    cl_uint* num_devices;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clGetDeviceInfo {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_device_id device;
    cl_device_info param_name;
    size_t param_value_size;
    void* param_value;
    size_t* param_value_size_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clCreateSubDevices {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_device_id in_device;
    const cl_device_partition_property* properties;
    cl_uint num_devices;
    cl_device_id* out_devices;
    cl_uint* num_devices_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clRetainDevice {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_device_id device;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clReleaseDevice {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_device_id device;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clSetDefaultDeviceCommandQueue {
#ifdef CL_API_SUFFIX__VERSION_2_1
    cl_context context;
    cl_device_id device;
    cl_command_queue command_queue;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_1
};

struct vcl_command_clGetDeviceAndHostTimer {
#ifdef CL_API_SUFFIX__VERSION_2_1
    cl_device_id device;
    cl_ulong* device_timestamp;
    cl_ulong* host_timestamp;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_1
};

struct vcl_command_clGetHostTimer {
#ifdef CL_API_SUFFIX__VERSION_2_1
    cl_device_id device;
    cl_ulong* host_timestamp;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_1
};

struct vcl_command_clCreateContext {
#ifdef CL_API_SUFFIX__VERSION_1_0
    const cl_context_properties* properties;
    cl_uint num_devices;
    const cl_device_id* devices;
    void* user_data;
    cl_int* errcode_ret;
    
    cl_context ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clCreateContextFromType {
#ifdef CL_API_SUFFIX__VERSION_1_0
    const cl_context_properties* properties;
    cl_device_type device_type;
    void* user_data;
    cl_int* errcode_ret;
    
    cl_context ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clRetainContext {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_context context;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clReleaseContext {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_context context;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clGetContextInfo {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_context context;
    cl_context_info param_name;
    size_t param_value_size;
    void* param_value;
    size_t* param_value_size_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clSetContextDestructorCallback {
#ifdef CL_API_SUFFIX__VERSION_3_0
    cl_context context;
    void* user_data;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_3_0
};

struct vcl_command_clCreateCommandQueueWithProperties {
#ifdef CL_API_SUFFIX__VERSION_2_0
    cl_context context;
    cl_device_id device;
    const cl_queue_properties* properties;
    cl_int* errcode_ret;
    
    cl_command_queue ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_0
};

struct vcl_command_clRetainCommandQueue {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clReleaseCommandQueue {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clGetCommandQueueInfo {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_command_queue_info param_name;
    size_t param_value_size;
    void* param_value;
    size_t* param_value_size_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clCreateBuffer {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_context context;
    cl_mem_flags flags;
    size_t size;
    void* host_ptr;
    cl_int* errcode_ret;
    
    cl_mem ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clCreateBufferWithProperties {
#ifdef CL_API_SUFFIX__VERSION_3_0
    cl_context context;
    const cl_mem_properties* properties;
    cl_mem_flags flags;
    size_t size;
    void* host_ptr;
    cl_int* errcode_ret;
    
    cl_mem ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_3_0
};

struct vcl_command_clCreateSubBuffer {
#ifdef CL_API_SUFFIX__VERSION_1_1
    cl_mem buffer;
    cl_mem_flags flags;
    cl_buffer_create_type buffer_create_type;
    const void* buffer_create_info;
    cl_int* errcode_ret;
    
    cl_mem ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1
};

struct vcl_command_clCreateImage {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_context context;
    cl_mem_flags flags;
    const cl_image_format* image_format;
    const cl_image_desc* image_desc;
    void* host_ptr;
    cl_int* errcode_ret;
    
    cl_mem ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clCreateImageWithProperties {
#ifdef CL_API_SUFFIX__VERSION_3_0
    cl_context context;
    const cl_mem_properties* properties;
    cl_mem_flags flags;
    const cl_image_format* image_format;
    const cl_image_desc* image_desc;
    void* host_ptr;
    cl_int* errcode_ret;
    
    cl_mem ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_3_0
};

struct vcl_command_clCreatePipe {
#ifdef CL_API_SUFFIX__VERSION_2_0
    cl_context context;
    cl_mem_flags flags;
    cl_uint pipe_packet_size;
    cl_uint pipe_max_packets;
    const cl_pipe_properties* properties;
    cl_int* errcode_ret;
    
    cl_mem ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_0
};

struct vcl_command_clRetainMemObject {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_mem memobj;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clReleaseMemObject {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_mem memobj;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clGetSupportedImageFormats {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_context context;
    cl_mem_flags flags;
    cl_mem_object_type image_type;
    cl_uint num_entries;
    cl_image_format* image_formats;
    cl_uint* num_image_formats;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clGetMemObjectInfo {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_mem memobj;
    cl_mem_info param_name;
    size_t param_value_size;
    void* param_value;
    size_t* param_value_size_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clGetImageInfo {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_mem image;
    cl_image_info param_name;
    size_t param_value_size;
    void* param_value;
    size_t* param_value_size_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clGetPipeInfo {
#ifdef CL_API_SUFFIX__VERSION_2_0
    cl_mem pipe;
    cl_pipe_info param_name;
    size_t param_value_size;
    void* param_value;
    size_t* param_value_size_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_0
};

struct vcl_command_clSetMemObjectDestructorCallback {
#ifdef CL_API_SUFFIX__VERSION_1_1
    cl_mem memobj;
    void* user_data;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1
};

struct vcl_command_clSVMAlloc {
#ifdef CL_API_SUFFIX__VERSION_2_0
    cl_context context;
    cl_svm_mem_flags flags;
    size_t size;
    cl_uint alignment;
    
    void* ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_0
};

struct vcl_command_clSVMFree {
#ifdef CL_API_SUFFIX__VERSION_2_0
    cl_context context;
    void* svm_pointer;
    
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_0
};

struct vcl_command_clCreateSamplerWithProperties {
#ifdef CL_API_SUFFIX__VERSION_2_0
    cl_context context;
    const cl_sampler_properties* sampler_properties;
    cl_int* errcode_ret;
    
    cl_sampler ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_0
};

struct vcl_command_clRetainSampler {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_sampler sampler;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clReleaseSampler {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_sampler sampler;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clGetSamplerInfo {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_sampler sampler;
    cl_sampler_info param_name;
    size_t param_value_size;
    void* param_value;
    size_t* param_value_size_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clCreateProgramWithSource {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_context context;
    cl_uint count;
    const char** strings;
    const size_t* lengths;
    cl_int* errcode_ret;
    
    cl_program ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clCreateProgramWithBinary {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_context context;
    cl_uint num_devices;
    const cl_device_id* device_list;
    const size_t* lengths;
    const unsigned char** binaries;
    cl_int* binary_status;
    cl_int* errcode_ret;
    
    cl_program ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clCreateProgramWithBuiltInKernels {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_context context;
    cl_uint num_devices;
    const cl_device_id* device_list;
    const char* kernel_names;
    cl_int* errcode_ret;
    
    cl_program ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clCreateProgramWithIL {
#ifdef CL_API_SUFFIX__VERSION_2_1
    cl_context context;
    const void* il;
    size_t length;
    cl_int* errcode_ret;
    
    cl_program ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_1
};

struct vcl_command_clRetainProgram {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_program program;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clReleaseProgram {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_program program;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clBuildProgram {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_program program;
    cl_uint num_devices;
    const cl_device_id* device_list;
    const char* options;
    void* user_data;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clCompileProgram {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_program program;
    cl_uint num_devices;
    const cl_device_id* device_list;
    const char* options;
    cl_uint num_input_headers;
    const cl_program* input_headers;
    const char** header_include_names;
    void* user_data;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clLinkProgram {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_context context;
    cl_uint num_devices;
    const cl_device_id* device_list;
    const char* options;
    cl_uint num_input_programs;
    const cl_program* input_programs;
    void* user_data;
    cl_int* errcode_ret;
    
    cl_program ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clSetProgramReleaseCallback {
#ifdef CL_API_SUFFIX__VERSION_2_2_DEPRECATED
    cl_program program;
    void* user_data;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_2_DEPRECATED
};

struct vcl_command_clSetProgramSpecializationConstant {
#ifdef CL_API_SUFFIX__VERSION_2_2
    cl_program program;
    cl_uint spec_id;
    size_t spec_size;
    const void* spec_value;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_2
};

struct vcl_command_clUnloadPlatformCompiler {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_platform_id platform;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clGetProgramInfo {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_program program;
    cl_program_info param_name;
    size_t param_value_size;
    void* param_value;
    size_t* param_value_size_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clGetProgramBuildInfo {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_program program;
    cl_device_id device;
    cl_program_build_info param_name;
    size_t param_value_size;
    void* param_value;
    size_t* param_value_size_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clCreateKernel {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_program program;
    const char* kernel_name;
    cl_int* errcode_ret;
    
    cl_kernel ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clCreateKernelsInProgram {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_program program;
    cl_uint num_kernels;
    cl_kernel* kernels;
    cl_uint* num_kernels_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clCloneKernel {
#ifdef CL_API_SUFFIX__VERSION_2_1
    cl_kernel source_kernel;
    cl_int* errcode_ret;
    
    cl_kernel ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_1
};

struct vcl_command_clRetainKernel {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_kernel kernel;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clReleaseKernel {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_kernel kernel;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clSetKernelArg {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_kernel kernel;
    cl_uint arg_index;
    size_t arg_size;
    const void* arg_value;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clSetKernelArgSVMPointer {
#ifdef CL_API_SUFFIX__VERSION_2_0
    cl_kernel kernel;
    cl_uint arg_index;
    const void* arg_value;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_0
};

struct vcl_command_clSetKernelExecInfo {
#ifdef CL_API_SUFFIX__VERSION_2_0
    cl_kernel kernel;
    cl_kernel_exec_info param_name;
    size_t param_value_size;
    const void* param_value;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_0
};

struct vcl_command_clGetKernelInfo {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_kernel kernel;
    cl_kernel_info param_name;
    size_t param_value_size;
    void* param_value;
    size_t* param_value_size_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clGetKernelArgInfo {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_kernel kernel;
    cl_uint arg_index;
    cl_kernel_arg_info param_name;
    size_t param_value_size;
    void* param_value;
    size_t* param_value_size_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clGetKernelWorkGroupInfo {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_kernel kernel;
    cl_device_id device;
    cl_kernel_work_group_info param_name;
    size_t param_value_size;
    void* param_value;
    size_t* param_value_size_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clGetKernelSubGroupInfo {
#ifdef CL_API_SUFFIX__VERSION_2_1
    cl_kernel kernel;
    cl_device_id device;
    cl_kernel_sub_group_info param_name;
    size_t input_value_size;
    const void* input_value;
    size_t param_value_size;
    void* param_value;
    size_t* param_value_size_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_1
};

struct vcl_command_clWaitForEvents {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_uint num_events;
    const cl_event* event_list;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clGetEventInfo {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_event event;
    cl_event_info param_name;
    size_t param_value_size;
    void* param_value;
    size_t* param_value_size_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clCreateUserEvent {
#ifdef CL_API_SUFFIX__VERSION_1_1
    cl_context context;
    cl_int* errcode_ret;
    
    cl_event ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1
};

struct vcl_command_clRetainEvent {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_event event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clReleaseEvent {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_event event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clSetUserEventStatus {
#ifdef CL_API_SUFFIX__VERSION_1_1
    cl_event event;
    cl_int execution_status;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1
};

struct vcl_command_clSetEventCallback {
#ifdef CL_API_SUFFIX__VERSION_1_1
    cl_event event;
    cl_int command_exec_callback_type;
    void* user_data;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1
};

struct vcl_command_clGetEventProfilingInfo {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_event event;
    cl_profiling_info param_name;
    size_t param_value_size;
    void* param_value;
    size_t* param_value_size_ret;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clFlush {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clFinish {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueReadBuffer {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_mem buffer;
    cl_bool blocking_read;
    size_t offset;
    size_t size;
    void* ptr;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueReadBufferRect {
#ifdef CL_API_SUFFIX__VERSION_1_1
    cl_command_queue command_queue;
    cl_mem buffer;
    cl_bool blocking_read;
    const size_t* buffer_origin;
    const size_t* host_origin;
    const size_t* region;
    size_t buffer_row_pitch;
    size_t buffer_slice_pitch;
    size_t host_row_pitch;
    size_t host_slice_pitch;
    void* ptr;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1
};

struct vcl_command_clEnqueueWriteBuffer {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_mem buffer;
    cl_bool blocking_write;
    size_t offset;
    size_t size;
    const void* ptr;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueWriteBufferRect {
#ifdef CL_API_SUFFIX__VERSION_1_1
    cl_command_queue command_queue;
    cl_mem buffer;
    cl_bool blocking_write;
    const size_t* buffer_origin;
    const size_t* host_origin;
    const size_t* region;
    size_t buffer_row_pitch;
    size_t buffer_slice_pitch;
    size_t host_row_pitch;
    size_t host_slice_pitch;
    const void* ptr;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1
};

struct vcl_command_clEnqueueFillBuffer {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_command_queue command_queue;
    cl_mem buffer;
    size_t pattern_size;
    const void* pattern;
    size_t offset;
    size_t size;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clEnqueueCopyBuffer {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_mem src_buffer;
    cl_mem dst_buffer;
    size_t src_offset;
    size_t dst_offset;
    size_t size;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueCopyBufferRect {
#ifdef CL_API_SUFFIX__VERSION_1_1
    cl_command_queue command_queue;
    cl_mem src_buffer;
    cl_mem dst_buffer;
    const size_t* src_origin;
    const size_t* dst_origin;
    const size_t* region;
    size_t src_row_pitch;
    size_t src_slice_pitch;
    size_t dst_row_pitch;
    size_t dst_slice_pitch;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1
};

struct vcl_command_clEnqueueReadImage {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_mem image;
    cl_bool blocking_read;
    const size_t* origin;
    const size_t* region;
    size_t row_pitch;
    size_t slice_pitch;
    void* ptr;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueWriteImage {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_mem image;
    cl_bool blocking_write;
    const size_t* origin;
    const size_t* region;
    size_t input_row_pitch;
    size_t input_slice_pitch;
    const void* ptr;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueFillImage {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_command_queue command_queue;
    cl_mem image;
    const void* fill_color;
    const size_t* origin;
    const size_t* region;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clEnqueueCopyImage {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_mem src_image;
    cl_mem dst_image;
    const size_t* src_origin;
    const size_t* dst_origin;
    const size_t* region;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueCopyImageToBuffer {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_mem src_image;
    cl_mem dst_buffer;
    const size_t* src_origin;
    const size_t* region;
    size_t dst_offset;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueCopyBufferToImage {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_mem src_buffer;
    cl_mem dst_image;
    size_t src_offset;
    const size_t* dst_origin;
    const size_t* region;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueMapBuffer {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_mem buffer;
    cl_bool blocking_map;
    cl_map_flags map_flags;
    size_t offset;
    size_t size;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    cl_int* errcode_ret;
    
    void* ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueMapImage {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_mem image;
    cl_bool blocking_map;
    cl_map_flags map_flags;
    const size_t* origin;
    const size_t* region;
    size_t* image_row_pitch;
    size_t* image_slice_pitch;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    cl_int* errcode_ret;
    
    void* ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueUnmapMemObject {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_mem memobj;
    void* mapped_ptr;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueMigrateMemObjects {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_command_queue command_queue;
    cl_uint num_mem_objects;
    const cl_mem* mem_objects;
    cl_mem_migration_flags flags;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clEnqueueNDRangeKernel {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_kernel kernel;
    cl_uint work_dim;
    const size_t* global_work_offset;
    const size_t* global_work_size;
    const size_t* local_work_size;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueNativeKernel {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    size_t cb_args;
    void* args;
    cl_uint num_mem_objects;
    const cl_mem* mem_list;
    const void** args_mem_loc;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueMarkerWithWaitList {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_command_queue command_queue;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clEnqueueBarrierWithWaitList {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_command_queue command_queue;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clEnqueueSVMFree {
#ifdef CL_API_SUFFIX__VERSION_2_0
    cl_command_queue command_queue;
    cl_uint num_svm_pointers;
    void* svm_pointers;
    void* user_data;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_0
};

struct vcl_command_clEnqueueSVMMemcpy {
#ifdef CL_API_SUFFIX__VERSION_2_0
    cl_command_queue command_queue;
    cl_bool blocking_copy;
    void* dst_ptr;
    const void* src_ptr;
    size_t size;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_0
};

struct vcl_command_clEnqueueSVMMemFill {
#ifdef CL_API_SUFFIX__VERSION_2_0
    cl_command_queue command_queue;
    void* svm_ptr;
    const void* pattern;
    size_t pattern_size;
    size_t size;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_0
};

struct vcl_command_clEnqueueSVMMap {
#ifdef CL_API_SUFFIX__VERSION_2_0
    cl_command_queue command_queue;
    cl_bool blocking_map;
    cl_map_flags flags;
    void* svm_ptr;
    size_t size;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_0
};

struct vcl_command_clEnqueueSVMUnmap {
#ifdef CL_API_SUFFIX__VERSION_2_0
    cl_command_queue command_queue;
    void* svm_ptr;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_0
};

struct vcl_command_clEnqueueSVMMigrateMem {
#ifdef CL_API_SUFFIX__VERSION_2_1
    cl_command_queue command_queue;
    cl_uint num_svm_pointers;
    const void** svm_pointers;
    const size_t* sizes;
    cl_mem_migration_flags flags;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_1
};

struct vcl_command_clGetExtensionFunctionAddressForPlatform {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_platform_id platform;
    const char* func_name;
    
    void* ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clSetCommandQueueProperty {
#ifdef CL_API_SUFFIX__VERSION_1_0_DEPRECATED
    cl_command_queue command_queue;
    cl_command_queue_properties properties;
    cl_bool enable;
    cl_command_queue_properties* old_properties;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0_DEPRECATED
};

struct vcl_command_clCreateImage2D {
#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
    cl_context context;
    cl_mem_flags flags;
    const cl_image_format* image_format;
    size_t image_width;
    size_t image_height;
    size_t image_row_pitch;
    void* host_ptr;
    cl_int* errcode_ret;
    
    cl_mem ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED
};

struct vcl_command_clCreateImage3D {
#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
    cl_context context;
    cl_mem_flags flags;
    const cl_image_format* image_format;
    size_t image_width;
    size_t image_height;
    size_t image_depth;
    size_t image_row_pitch;
    size_t image_slice_pitch;
    void* host_ptr;
    cl_int* errcode_ret;
    
    cl_mem ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED
};

struct vcl_command_clEnqueueMarker {
#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
    cl_command_queue command_queue;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED
};

struct vcl_command_clEnqueueWaitForEvents {
#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
    cl_command_queue command_queue;
    cl_uint num_events;
    const cl_event* event_list;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED
};

struct vcl_command_clEnqueueBarrier {
#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
    cl_command_queue command_queue;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED
};

struct vcl_command_clUnloadCompiler {
#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED
};

struct vcl_command_clGetExtensionFunctionAddress {
#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
    const char* func_name;
    
    void* ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED
};

struct vcl_command_clCreateCommandQueue {
#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
    cl_context context;
    cl_device_id device;
    cl_command_queue_properties properties;
    cl_int* errcode_ret;
    
    cl_command_queue ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED
};

struct vcl_command_clCreateSampler {
#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
    cl_context context;
    cl_bool normalized_coords;
    cl_addressing_mode addressing_mode;
    cl_filter_mode filter_mode;
    cl_int* errcode_ret;
    
    cl_sampler ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED
};

struct vcl_command_clEnqueueTask {
#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
    cl_command_queue command_queue;
    cl_kernel kernel;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED
};

struct vcl_command_clSetReplyBufferMESA {
    int32_t resource_id;
    
};

struct vcl_command_clCreateContextMESA {
#ifdef CL_API_SUFFIX__VERSION_1_0
    const cl_context_properties* properties;
    cl_uint num_devices;
    const cl_device_id* devices;
    void* user_data;
    cl_context* context;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clCreateCommandQueueMESA {
#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
    cl_context context;
    cl_device_id device;
    cl_command_queue_properties properties;
    cl_command_queue* queue;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED
};

struct vcl_command_clCreateCommandQueueWithPropertiesMESA {
#ifdef CL_API_SUFFIX__VERSION_2_0
    cl_context context;
    cl_device_id device;
    size_t properties_size;
    const cl_queue_properties* properties;
    cl_command_queue* queue;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_0
};

struct vcl_command_clCreateUserEventMESA {
#ifdef CL_API_SUFFIX__VERSION_1_1
    cl_context context;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1
};

struct vcl_command_clCreateBufferMESA {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_context context;
    cl_mem_flags flags;
    size_t size;
    const void* host_ptr;
    cl_mem* buffer;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clCreateBufferWithPropertiesMESA {
#ifdef CL_API_SUFFIX__VERSION_3_0
    cl_context context;
    const cl_mem_properties* properties;
    cl_mem_flags flags;
    size_t size;
    void* host_ptr;
    cl_mem* buffer;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_3_0
};

struct vcl_command_clCreateImage2DMESA {
#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
    cl_context context;
    cl_mem_flags flags;
    const cl_image_format* image_format;
    size_t image_width;
    size_t image_height;
    size_t image_row_pitch;
    size_t size;
    const void* host_ptr;
    cl_mem* image;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED
};

struct vcl_command_clCreateImage3DMESA {
#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
    cl_context context;
    cl_mem_flags flags;
    const cl_image_format* image_format;
    size_t image_width;
    size_t image_height;
    size_t image_depth;
    size_t image_row_pitch;
    size_t image_slice_pitch;
    size_t size;
    const void* host_ptr;
    cl_mem* image;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED
};

struct vcl_command_clCreateKernelMESA {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_program program;
    const char* kernel_name;
    cl_kernel* kernel;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clCloneKernelMESA {
#ifdef CL_API_SUFFIX__VERSION_2_1
    cl_kernel source_kernel;
    cl_kernel* kernel;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_1
};

struct vcl_command_clCreateProgramWithSourceMESA {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_context context;
    cl_uint count;
    const char* const* strings;
    const size_t* lengths;
    cl_program* program;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clCreateProgramWithBinaryMESA {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_context context;
    cl_uint num_devices;
    const cl_device_id* device_list;
    const size_t* lengths;
    size_t binaries_size;
    const uint8_t* binaries;
    cl_int* binary_status;
    cl_program* program;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clCreateProgramWithILMESA {
#ifdef CL_API_SUFFIX__VERSION_2_1
    cl_context context;
    size_t length;
    const void* il;
    cl_program* program;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_1
};

struct vcl_command_clLinkProgramMESA {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_context context;
    cl_uint num_devices;
    const cl_device_id* device_list;
    const char* options;
    cl_uint num_input_programs;
    const cl_program* input_programs;
    void* user_data;
    cl_program* program;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clCreateSamplerMESA {
#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
    cl_context context;
    cl_bool normalized_coords;
    cl_addressing_mode addressing_mode;
    cl_filter_mode filter_mode;
    cl_sampler* sampler;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED
};

struct vcl_command_clCreateSamplerWithPropertiesMESA {
#ifdef CL_API_SUFFIX__VERSION_2_0
    cl_context context;
    const cl_sampler_properties* sampler_properties;
    cl_sampler* sampler;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_2_0
};

struct vcl_command_clCreateSubBufferMESA {
#ifdef CL_API_SUFFIX__VERSION_1_1
    cl_mem buffer;
    cl_mem_flags flags;
    cl_buffer_create_type buffer_create_type;
    size_t buffer_create_info_size;
    const void* buffer_create_info;
    cl_mem* sub_buffer;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_1
};

struct vcl_command_clCreateImageMESA {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_context context;
    cl_mem_flags flags;
    const cl_image_format* image_format;
    const cl_image_desc_MESA* image_desc;
    size_t size;
    const void* host_ptr;
    cl_mem* image;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clCreateImageWithPropertiesMESA {
#ifdef CL_API_SUFFIX__VERSION_3_0
    cl_context context;
    const cl_mem_properties* properties;
    cl_mem_flags flags;
    const cl_image_format* image_format;
    const cl_image_desc_MESA* image_desc;
    size_t size;
    const void* host_ptr;
    cl_mem* image;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_3_0
};

struct vcl_command_clEnqueueReadImageMESA {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_mem image;
    cl_bool blocking_read;
    const size_t* origin;
    const size_t* region;
    size_t row_pitch;
    size_t slice_pitch;
    size_t size;
    void* ptr;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueWriteImageMESA {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_mem image;
    cl_bool blocking_write;
    const size_t* origin;
    const size_t* region;
    size_t input_row_pitch;
    size_t input_slice_pitch;
    size_t size;
    const void* ptr;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueFillImageMESA {
#ifdef CL_API_SUFFIX__VERSION_1_2
    cl_command_queue command_queue;
    cl_mem image;
    size_t size;
    const void* fill_color;
    const size_t* origin;
    const size_t* region;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_2
};

struct vcl_command_clEnqueueMapBufferMESA {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_mem buffer;
    cl_bool blocking_map;
    cl_map_flags map_flags;
    size_t offset;
    size_t size;
    void* ptr;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueMapImageMESA {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_mem image;
    cl_bool blocking_map;
    cl_map_flags map_flags;
    const size_t* origin;
    const size_t* region;
    size_t* image_row_pitch;
    size_t* image_slice_pitch;
    size_t size;
    void* ptr;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueUnmapMemObjectMESA {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_mem memobj;
    size_t size;
    const void* mapped_ptr;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_command_clEnqueueNDRangeKernelMESA {
#ifdef CL_API_SUFFIX__VERSION_1_0
    cl_command_queue command_queue;
    cl_kernel kernel;
    cl_uint work_dim;
    cl_uint global_work_offset_dim;
    const size_t* global_work_offset;
    cl_uint global_work_size_dim;
    const size_t* global_work_size;
    cl_uint local_work_size_dim;
    const size_t* local_work_size;
    cl_uint num_events_in_wait_list;
    const cl_event* event_wait_list;
    cl_event* event;
    
    cl_int ret;
#else //
    cl_uint dummy;
#endif // CL_API_SUFFIX__VERSION_1_0
};

struct vcl_dispatch_context {
    void *data;
    void (*debug_log)(struct vcl_dispatch_context *ctx, const char *msg);

    struct vcl_cs_encoder *encoder;
    struct vcl_cs_decoder *decoder;

    void (*dispatch_clGetPlatformIDs)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetPlatformIDs *args);
    void (*dispatch_clGetPlatformInfo)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetPlatformInfo *args);
    void (*dispatch_clGetDeviceIDs)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetDeviceIDs *args);
    void (*dispatch_clGetDeviceInfo)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetDeviceInfo *args);
    void (*dispatch_clCreateSubDevices)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateSubDevices *args);
    void (*dispatch_clRetainDevice)(struct vcl_dispatch_context *ctx, struct vcl_command_clRetainDevice *args);
    void (*dispatch_clReleaseDevice)(struct vcl_dispatch_context *ctx, struct vcl_command_clReleaseDevice *args);
    void (*dispatch_clSetDefaultDeviceCommandQueue)(struct vcl_dispatch_context *ctx, struct vcl_command_clSetDefaultDeviceCommandQueue *args);
    void (*dispatch_clGetDeviceAndHostTimer)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetDeviceAndHostTimer *args);
    void (*dispatch_clGetHostTimer)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetHostTimer *args);
    void (*dispatch_clCreateContext)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateContext *args);
    void (*dispatch_clCreateContextFromType)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateContextFromType *args);
    void (*dispatch_clRetainContext)(struct vcl_dispatch_context *ctx, struct vcl_command_clRetainContext *args);
    void (*dispatch_clReleaseContext)(struct vcl_dispatch_context *ctx, struct vcl_command_clReleaseContext *args);
    void (*dispatch_clGetContextInfo)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetContextInfo *args);
    void (*dispatch_clSetContextDestructorCallback)(struct vcl_dispatch_context *ctx, struct vcl_command_clSetContextDestructorCallback *args);
    void (*dispatch_clCreateCommandQueueWithProperties)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateCommandQueueWithProperties *args);
    void (*dispatch_clRetainCommandQueue)(struct vcl_dispatch_context *ctx, struct vcl_command_clRetainCommandQueue *args);
    void (*dispatch_clReleaseCommandQueue)(struct vcl_dispatch_context *ctx, struct vcl_command_clReleaseCommandQueue *args);
    void (*dispatch_clGetCommandQueueInfo)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetCommandQueueInfo *args);
    void (*dispatch_clCreateBuffer)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateBuffer *args);
    void (*dispatch_clCreateBufferWithProperties)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateBufferWithProperties *args);
    void (*dispatch_clCreateSubBuffer)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateSubBuffer *args);
    void (*dispatch_clCreateImage)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateImage *args);
    void (*dispatch_clCreateImageWithProperties)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateImageWithProperties *args);
    void (*dispatch_clCreatePipe)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreatePipe *args);
    void (*dispatch_clRetainMemObject)(struct vcl_dispatch_context *ctx, struct vcl_command_clRetainMemObject *args);
    void (*dispatch_clReleaseMemObject)(struct vcl_dispatch_context *ctx, struct vcl_command_clReleaseMemObject *args);
    void (*dispatch_clGetSupportedImageFormats)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetSupportedImageFormats *args);
    void (*dispatch_clGetMemObjectInfo)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetMemObjectInfo *args);
    void (*dispatch_clGetImageInfo)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetImageInfo *args);
    void (*dispatch_clGetPipeInfo)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetPipeInfo *args);
    void (*dispatch_clSetMemObjectDestructorCallback)(struct vcl_dispatch_context *ctx, struct vcl_command_clSetMemObjectDestructorCallback *args);
    void (*dispatch_clSVMAlloc)(struct vcl_dispatch_context *ctx, struct vcl_command_clSVMAlloc *args);
    void (*dispatch_clSVMFree)(struct vcl_dispatch_context *ctx, struct vcl_command_clSVMFree *args);
    void (*dispatch_clCreateSamplerWithProperties)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateSamplerWithProperties *args);
    void (*dispatch_clRetainSampler)(struct vcl_dispatch_context *ctx, struct vcl_command_clRetainSampler *args);
    void (*dispatch_clReleaseSampler)(struct vcl_dispatch_context *ctx, struct vcl_command_clReleaseSampler *args);
    void (*dispatch_clGetSamplerInfo)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetSamplerInfo *args);
    void (*dispatch_clCreateProgramWithSource)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateProgramWithSource *args);
    void (*dispatch_clCreateProgramWithBinary)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateProgramWithBinary *args);
    void (*dispatch_clCreateProgramWithBuiltInKernels)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateProgramWithBuiltInKernels *args);
    void (*dispatch_clCreateProgramWithIL)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateProgramWithIL *args);
    void (*dispatch_clRetainProgram)(struct vcl_dispatch_context *ctx, struct vcl_command_clRetainProgram *args);
    void (*dispatch_clReleaseProgram)(struct vcl_dispatch_context *ctx, struct vcl_command_clReleaseProgram *args);
    void (*dispatch_clBuildProgram)(struct vcl_dispatch_context *ctx, struct vcl_command_clBuildProgram *args);
    void (*dispatch_clCompileProgram)(struct vcl_dispatch_context *ctx, struct vcl_command_clCompileProgram *args);
    void (*dispatch_clLinkProgram)(struct vcl_dispatch_context *ctx, struct vcl_command_clLinkProgram *args);
    void (*dispatch_clSetProgramReleaseCallback)(struct vcl_dispatch_context *ctx, struct vcl_command_clSetProgramReleaseCallback *args);
    void (*dispatch_clSetProgramSpecializationConstant)(struct vcl_dispatch_context *ctx, struct vcl_command_clSetProgramSpecializationConstant *args);
    void (*dispatch_clUnloadPlatformCompiler)(struct vcl_dispatch_context *ctx, struct vcl_command_clUnloadPlatformCompiler *args);
    void (*dispatch_clGetProgramInfo)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetProgramInfo *args);
    void (*dispatch_clGetProgramBuildInfo)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetProgramBuildInfo *args);
    void (*dispatch_clCreateKernel)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateKernel *args);
    void (*dispatch_clCreateKernelsInProgram)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateKernelsInProgram *args);
    void (*dispatch_clCloneKernel)(struct vcl_dispatch_context *ctx, struct vcl_command_clCloneKernel *args);
    void (*dispatch_clRetainKernel)(struct vcl_dispatch_context *ctx, struct vcl_command_clRetainKernel *args);
    void (*dispatch_clReleaseKernel)(struct vcl_dispatch_context *ctx, struct vcl_command_clReleaseKernel *args);
    void (*dispatch_clSetKernelArg)(struct vcl_dispatch_context *ctx, struct vcl_command_clSetKernelArg *args);
    void (*dispatch_clSetKernelArgSVMPointer)(struct vcl_dispatch_context *ctx, struct vcl_command_clSetKernelArgSVMPointer *args);
    void (*dispatch_clSetKernelExecInfo)(struct vcl_dispatch_context *ctx, struct vcl_command_clSetKernelExecInfo *args);
    void (*dispatch_clGetKernelInfo)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetKernelInfo *args);
    void (*dispatch_clGetKernelArgInfo)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetKernelArgInfo *args);
    void (*dispatch_clGetKernelWorkGroupInfo)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetKernelWorkGroupInfo *args);
    void (*dispatch_clGetKernelSubGroupInfo)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetKernelSubGroupInfo *args);
    void (*dispatch_clWaitForEvents)(struct vcl_dispatch_context *ctx, struct vcl_command_clWaitForEvents *args);
    void (*dispatch_clGetEventInfo)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetEventInfo *args);
    void (*dispatch_clCreateUserEvent)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateUserEvent *args);
    void (*dispatch_clRetainEvent)(struct vcl_dispatch_context *ctx, struct vcl_command_clRetainEvent *args);
    void (*dispatch_clReleaseEvent)(struct vcl_dispatch_context *ctx, struct vcl_command_clReleaseEvent *args);
    void (*dispatch_clSetUserEventStatus)(struct vcl_dispatch_context *ctx, struct vcl_command_clSetUserEventStatus *args);
    void (*dispatch_clSetEventCallback)(struct vcl_dispatch_context *ctx, struct vcl_command_clSetEventCallback *args);
    void (*dispatch_clGetEventProfilingInfo)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetEventProfilingInfo *args);
    void (*dispatch_clFlush)(struct vcl_dispatch_context *ctx, struct vcl_command_clFlush *args);
    void (*dispatch_clFinish)(struct vcl_dispatch_context *ctx, struct vcl_command_clFinish *args);
    void (*dispatch_clEnqueueReadBuffer)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueReadBuffer *args);
    void (*dispatch_clEnqueueReadBufferRect)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueReadBufferRect *args);
    void (*dispatch_clEnqueueWriteBuffer)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueWriteBuffer *args);
    void (*dispatch_clEnqueueWriteBufferRect)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueWriteBufferRect *args);
    void (*dispatch_clEnqueueFillBuffer)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueFillBuffer *args);
    void (*dispatch_clEnqueueCopyBuffer)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueCopyBuffer *args);
    void (*dispatch_clEnqueueCopyBufferRect)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueCopyBufferRect *args);
    void (*dispatch_clEnqueueReadImage)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueReadImage *args);
    void (*dispatch_clEnqueueWriteImage)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueWriteImage *args);
    void (*dispatch_clEnqueueFillImage)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueFillImage *args);
    void (*dispatch_clEnqueueCopyImage)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueCopyImage *args);
    void (*dispatch_clEnqueueCopyImageToBuffer)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueCopyImageToBuffer *args);
    void (*dispatch_clEnqueueCopyBufferToImage)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueCopyBufferToImage *args);
    void (*dispatch_clEnqueueMapBuffer)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueMapBuffer *args);
    void (*dispatch_clEnqueueMapImage)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueMapImage *args);
    void (*dispatch_clEnqueueUnmapMemObject)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueUnmapMemObject *args);
    void (*dispatch_clEnqueueMigrateMemObjects)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueMigrateMemObjects *args);
    void (*dispatch_clEnqueueNDRangeKernel)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueNDRangeKernel *args);
    void (*dispatch_clEnqueueNativeKernel)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueNativeKernel *args);
    void (*dispatch_clEnqueueMarkerWithWaitList)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueMarkerWithWaitList *args);
    void (*dispatch_clEnqueueBarrierWithWaitList)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueBarrierWithWaitList *args);
    void (*dispatch_clEnqueueSVMFree)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueSVMFree *args);
    void (*dispatch_clEnqueueSVMMemcpy)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueSVMMemcpy *args);
    void (*dispatch_clEnqueueSVMMemFill)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueSVMMemFill *args);
    void (*dispatch_clEnqueueSVMMap)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueSVMMap *args);
    void (*dispatch_clEnqueueSVMUnmap)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueSVMUnmap *args);
    void (*dispatch_clEnqueueSVMMigrateMem)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueSVMMigrateMem *args);
    void (*dispatch_clGetExtensionFunctionAddressForPlatform)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetExtensionFunctionAddressForPlatform *args);
    void (*dispatch_clSetCommandQueueProperty)(struct vcl_dispatch_context *ctx, struct vcl_command_clSetCommandQueueProperty *args);
    void (*dispatch_clCreateImage2D)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateImage2D *args);
    void (*dispatch_clCreateImage3D)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateImage3D *args);
    void (*dispatch_clEnqueueMarker)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueMarker *args);
    void (*dispatch_clEnqueueWaitForEvents)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueWaitForEvents *args);
    void (*dispatch_clEnqueueBarrier)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueBarrier *args);
    void (*dispatch_clUnloadCompiler)(struct vcl_dispatch_context *ctx, struct vcl_command_clUnloadCompiler *args);
    void (*dispatch_clGetExtensionFunctionAddress)(struct vcl_dispatch_context *ctx, struct vcl_command_clGetExtensionFunctionAddress *args);
    void (*dispatch_clCreateCommandQueue)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateCommandQueue *args);
    void (*dispatch_clCreateSampler)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateSampler *args);
    void (*dispatch_clEnqueueTask)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueTask *args);
    void (*dispatch_clSetReplyBufferMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clSetReplyBufferMESA *args);
    void (*dispatch_clCreateContextMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateContextMESA *args);
    void (*dispatch_clCreateCommandQueueMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateCommandQueueMESA *args);
    void (*dispatch_clCreateCommandQueueWithPropertiesMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateCommandQueueWithPropertiesMESA *args);
    void (*dispatch_clCreateUserEventMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateUserEventMESA *args);
    void (*dispatch_clCreateBufferMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateBufferMESA *args);
    void (*dispatch_clCreateBufferWithPropertiesMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateBufferWithPropertiesMESA *args);
    void (*dispatch_clCreateImage2DMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateImage2DMESA *args);
    void (*dispatch_clCreateImage3DMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateImage3DMESA *args);
    void (*dispatch_clCreateKernelMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateKernelMESA *args);
    void (*dispatch_clCloneKernelMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCloneKernelMESA *args);
    void (*dispatch_clCreateProgramWithSourceMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateProgramWithSourceMESA *args);
    void (*dispatch_clCreateProgramWithBinaryMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateProgramWithBinaryMESA *args);
    void (*dispatch_clCreateProgramWithILMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateProgramWithILMESA *args);
    void (*dispatch_clLinkProgramMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clLinkProgramMESA *args);
    void (*dispatch_clCreateSamplerMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateSamplerMESA *args);
    void (*dispatch_clCreateSamplerWithPropertiesMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateSamplerWithPropertiesMESA *args);
    void (*dispatch_clCreateSubBufferMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateSubBufferMESA *args);
    void (*dispatch_clCreateImageMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateImageMESA *args);
    void (*dispatch_clCreateImageWithPropertiesMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clCreateImageWithPropertiesMESA *args);
    void (*dispatch_clEnqueueReadImageMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueReadImageMESA *args);
    void (*dispatch_clEnqueueWriteImageMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueWriteImageMESA *args);
    void (*dispatch_clEnqueueFillImageMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueFillImageMESA *args);
    void (*dispatch_clEnqueueMapBufferMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueMapBufferMESA *args);
    void (*dispatch_clEnqueueMapImageMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueMapImageMESA *args);
    void (*dispatch_clEnqueueUnmapMemObjectMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueUnmapMemObjectMESA *args);
    void (*dispatch_clEnqueueNDRangeKernelMESA)(struct vcl_dispatch_context *ctx, struct vcl_command_clEnqueueNDRangeKernelMESA *args);
};

static inline void vcl_dispatch_debug_log(struct vcl_dispatch_context *ctx, const char *format, ...)
{
    char msg[256];
    va_list va;

    if (!ctx->debug_log)
        return;

    va_start(va, format);
    vsnprintf(msg, sizeof(msg), format, va);
    ctx->debug_log(ctx, msg);
    va_end(va);
}

static inline bool vcl_dispatch_should_log_result(cl_int result)
{
    switch (result) {
    default:
        /* log all other errors */
        return result < CL_SUCCESS;
    }
}

#endif /* VCL_PROTOCOL_RENDERER_DEFINES_H */
