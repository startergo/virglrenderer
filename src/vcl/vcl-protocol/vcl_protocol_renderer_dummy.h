/* This file is generated by vcl-protocol.  See vcl_protocol_renderer.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#ifndef VCL_PROTOCOL_RENDERER_DUMMY_H
#define VCL_PROTOCOL_RENDERER_DUMMY_H

#include "vcl_protocol_renderer_structs.h"

#pragma GCC diagnostic push
#if !defined(__clang__) && defined(__GNUC__) && __GNUC__ >= 12
#pragma GCC diagnostic ignored "-Wdangling-pointer"
#endif
#pragma GCC diagnostic ignored "-Wpointer-arith"
#pragma GCC diagnostic ignored "-Wunused-parameter"

/*
 * These structs/unions/commands are not included
 *
 *   clSetContextDestructorCallback
 *   clCreateBuffer
 *   clCreateBufferWithProperties
 *   clCreateSubBuffer
 *   clCreateImage
 *   clCreateImageWithProperties
 *   clGetPipeInfo
 *   clSetMemObjectDestructorCallback
 *   clSVMAlloc
 *   clSVMFree
 *   clCreateProgramWithBinary
 *   clCreateProgramWithIL
 *   clLinkProgram
 *   clSetProgramReleaseCallback
 *   clSetProgramSpecializationConstant
 *   clEnqueueReadImage
 *   clEnqueueWriteImage
 *   clEnqueueFillImage
 *   clEnqueueMapBuffer
 *   clEnqueueMapImage
 *   clEnqueueUnmapMemObject
 *   clEnqueueSVMFree
 *   clEnqueueSVMMemcpy
 *   clEnqueueSVMMemFill
 *   clEnqueueSVMMap
 *   clEnqueueSVMUnmap
 *   clEnqueueSVMMigrateMem
 *   clGetExtensionFunctionAddressForPlatform
 *   clCreateImage2D
 *   clCreateImage3D
 *   clGetExtensionFunctionAddress
 */

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_decode_clCreateSubDevices_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateSubDevices *args)
{
    vcl_decode_cl_device_id_lookup(dec, &args->in_device);
    if (vcl_decode_simple_pointer(dec)) {
        args->properties = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->properties));
        if (!args->properties) return;
        vcl_decode_cl_device_partition_property(dec, (cl_device_partition_property *)args->properties);
    } else {
        args->properties = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    vcl_decode_cl_uint(dec, &args->num_devices);
    if (vcl_decode_simple_pointer(dec)) {
        args->out_devices = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->out_devices));
        if (!args->out_devices) return;
        vcl_decode_cl_device_id_temp(dec, args->out_devices);
    } else {
        args->out_devices = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->num_devices_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->num_devices_ret));
        if (!args->num_devices_ret) return;
    } else {
        args->num_devices_ret = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_replace_clCreateSubDevices_args_handle(struct vcl_command_clCreateSubDevices *args)
{
    vcl_replace_cl_device_id_handle(&args->in_device);
    /* skip args->properties */
    /* skip args->num_devices */
    /* skip args->out_devices */
    /* skip args->num_devices_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_encode_clCreateSubDevices_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateSubDevices *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateSubDevices_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->in_device */
    /* skip args->properties */
    /* skip args->num_devices */
    if (vcl_encode_simple_pointer(enc, args->out_devices))
        vcl_encode_cl_device_id(enc, args->out_devices);
    if (vcl_encode_simple_pointer(enc, args->num_devices_ret))
        vcl_encode_cl_uint(enc, args->num_devices_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_decode_clRetainDevice_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clRetainDevice *args)
{
    vcl_decode_cl_device_id_lookup(dec, &args->device);
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_replace_clRetainDevice_args_handle(struct vcl_command_clRetainDevice *args)
{
    vcl_replace_cl_device_id_handle(&args->device);
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_encode_clRetainDevice_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clRetainDevice *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clRetainDevice_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->device */
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_decode_clReleaseDevice_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clReleaseDevice *args)
{
    vcl_decode_cl_device_id_lookup(dec, &args->device);
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_replace_clReleaseDevice_args_handle(struct vcl_command_clReleaseDevice *args)
{
    vcl_replace_cl_device_id_handle(&args->device);
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_encode_clReleaseDevice_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clReleaseDevice *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clReleaseDevice_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->device */
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_decode_clGetDeviceAndHostTimer_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetDeviceAndHostTimer *args)
{
    vcl_decode_cl_device_id_lookup(dec, &args->device);
    if (vcl_decode_simple_pointer(dec)) {
        args->device_timestamp = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->device_timestamp));
        if (!args->device_timestamp) return;
    } else {
        args->device_timestamp = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->host_timestamp = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->host_timestamp));
        if (!args->host_timestamp) return;
    } else {
        args->host_timestamp = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_replace_clGetDeviceAndHostTimer_args_handle(struct vcl_command_clGetDeviceAndHostTimer *args)
{
    vcl_replace_cl_device_id_handle(&args->device);
    /* skip args->device_timestamp */
    /* skip args->host_timestamp */
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_encode_clGetDeviceAndHostTimer_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetDeviceAndHostTimer *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetDeviceAndHostTimer_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->device */
    if (vcl_encode_simple_pointer(enc, args->device_timestamp))
        vcl_encode_cl_ulong(enc, args->device_timestamp);
    if (vcl_encode_simple_pointer(enc, args->host_timestamp))
        vcl_encode_cl_ulong(enc, args->host_timestamp);
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_decode_clGetHostTimer_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetHostTimer *args)
{
    vcl_decode_cl_device_id_lookup(dec, &args->device);
    if (vcl_decode_simple_pointer(dec)) {
        args->host_timestamp = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->host_timestamp));
        if (!args->host_timestamp) return;
    } else {
        args->host_timestamp = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_replace_clGetHostTimer_args_handle(struct vcl_command_clGetHostTimer *args)
{
    vcl_replace_cl_device_id_handle(&args->device);
    /* skip args->host_timestamp */
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_encode_clGetHostTimer_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetHostTimer *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetHostTimer_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->device */
    if (vcl_encode_simple_pointer(enc, args->host_timestamp))
        vcl_encode_cl_ulong(enc, args->host_timestamp);
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clCreateContext_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateContext *args)
{
    if (vcl_peek_array_size(dec)) {
        const size_t null_terminated_array_size = vcl_decode_array_size_unchecked(dec);
        args->properties = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->properties), null_terminated_array_size);
        if (!args->properties) return;
        vcl_decode_cl_context_properties_array(dec, (cl_context_properties *)args->properties, null_terminated_array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->properties = NULL;
    }
    vcl_decode_cl_uint(dec, &args->num_devices);
    if (vcl_decode_simple_pointer(dec)) {
        args->devices = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->devices));
        if (!args->devices) return;
        vcl_decode_cl_device_id_lookup(dec, (cl_device_id *)args->devices);
    } else {
        args->devices = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        vcl_cs_decoder_set_fatal(dec);
    } else {
        args->user_data = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->errcode_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->errcode_ret));
        if (!args->errcode_ret) return;
    } else {
        args->errcode_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clCreateContext_args_handle(struct vcl_command_clCreateContext *args)
{
    /* skip args->properties */
    /* skip args->num_devices */
    if (args->devices)
        vcl_replace_cl_device_id_handle((cl_device_id *)args->devices);
    /* skip args->user_data */
    /* skip args->errcode_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clCreateContext_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateContext *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateContext_EXT});

    vcl_encode_cl_context(enc, &args->ret);
    /* skip args->properties */
    /* skip args->num_devices */
    /* skip args->devices */
    if (vcl_encode_simple_pointer(enc, args->user_data))
        assert(false);
    if (vcl_encode_simple_pointer(enc, args->errcode_ret))
        vcl_encode_cl_int(enc, args->errcode_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clCreateContextFromType_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateContextFromType *args)
{
    if (vcl_decode_simple_pointer(dec)) {
        args->properties = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->properties));
        if (!args->properties) return;
        vcl_decode_cl_context_properties(dec, (cl_context_properties *)args->properties);
    } else {
        args->properties = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    vcl_decode_cl_device_type(dec, &args->device_type);
    if (vcl_decode_simple_pointer(dec)) {
        vcl_cs_decoder_set_fatal(dec);
    } else {
        args->user_data = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->errcode_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->errcode_ret));
        if (!args->errcode_ret) return;
    } else {
        args->errcode_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clCreateContextFromType_args_handle(struct vcl_command_clCreateContextFromType *args)
{
    /* skip args->properties */
    /* skip args->device_type */
    /* skip args->user_data */
    /* skip args->errcode_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clCreateContextFromType_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateContextFromType *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateContextFromType_EXT});

    vcl_encode_cl_context(enc, &args->ret);
    /* skip args->properties */
    /* skip args->device_type */
    if (vcl_encode_simple_pointer(enc, args->user_data))
        assert(false);
    if (vcl_encode_simple_pointer(enc, args->errcode_ret))
        vcl_encode_cl_int(enc, args->errcode_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_decode_clCreateCommandQueueWithProperties_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateCommandQueueWithProperties *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_device_id_lookup(dec, &args->device);
    if (vcl_decode_simple_pointer(dec)) {
        args->properties = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->properties));
        if (!args->properties) return;
        vcl_decode_cl_queue_properties(dec, (cl_queue_properties *)args->properties);
    } else {
        args->properties = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->errcode_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->errcode_ret));
        if (!args->errcode_ret) return;
    } else {
        args->errcode_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_replace_clCreateCommandQueueWithProperties_args_handle(struct vcl_command_clCreateCommandQueueWithProperties *args)
{
    vcl_replace_cl_context_handle(&args->context);
    vcl_replace_cl_device_id_handle(&args->device);
    /* skip args->properties */
    /* skip args->errcode_ret */
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_encode_clCreateCommandQueueWithProperties_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateCommandQueueWithProperties *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateCommandQueueWithProperties_EXT});

    vcl_encode_cl_command_queue(enc, &args->ret);
    /* skip args->context */
    /* skip args->device */
    /* skip args->properties */
    if (vcl_encode_simple_pointer(enc, args->errcode_ret))
        vcl_encode_cl_int(enc, args->errcode_ret);
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clRetainCommandQueue_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clRetainCommandQueue *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clRetainCommandQueue_args_handle(struct vcl_command_clRetainCommandQueue *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clRetainCommandQueue_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clRetainCommandQueue *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clRetainCommandQueue_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_decode_clCreatePipe_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreatePipe *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_mem_flags(dec, &args->flags);
    vcl_decode_cl_uint(dec, &args->pipe_packet_size);
    vcl_decode_cl_uint(dec, &args->pipe_max_packets);
    if (vcl_decode_simple_pointer(dec)) {
        args->properties = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->properties));
        if (!args->properties) return;
        vcl_decode_cl_pipe_properties(dec, (cl_pipe_properties *)args->properties);
    } else {
        args->properties = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->errcode_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->errcode_ret));
        if (!args->errcode_ret) return;
    } else {
        args->errcode_ret = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_replace_clCreatePipe_args_handle(struct vcl_command_clCreatePipe *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->flags */
    /* skip args->pipe_packet_size */
    /* skip args->pipe_max_packets */
    /* skip args->properties */
    /* skip args->errcode_ret */
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_encode_clCreatePipe_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreatePipe *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreatePipe_EXT});

    vcl_encode_cl_mem(enc, &args->ret);
    /* skip args->context */
    /* skip args->flags */
    /* skip args->pipe_packet_size */
    /* skip args->pipe_max_packets */
    /* skip args->properties */
    if (vcl_encode_simple_pointer(enc, args->errcode_ret))
        vcl_encode_cl_int(enc, args->errcode_ret);
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clRetainMemObject_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clRetainMemObject *args)
{
    vcl_decode_cl_mem_lookup(dec, &args->memobj);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clRetainMemObject_args_handle(struct vcl_command_clRetainMemObject *args)
{
    vcl_replace_cl_mem_handle(&args->memobj);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clRetainMemObject_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clRetainMemObject *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clRetainMemObject_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->memobj */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_decode_clCreateSamplerWithProperties_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateSamplerWithProperties *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    if (vcl_decode_simple_pointer(dec)) {
        args->sampler_properties = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->sampler_properties));
        if (!args->sampler_properties) return;
        vcl_decode_cl_sampler_properties(dec, (cl_sampler_properties *)args->sampler_properties);
    } else {
        args->sampler_properties = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->errcode_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->errcode_ret));
        if (!args->errcode_ret) return;
    } else {
        args->errcode_ret = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_replace_clCreateSamplerWithProperties_args_handle(struct vcl_command_clCreateSamplerWithProperties *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->sampler_properties */
    /* skip args->errcode_ret */
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_encode_clCreateSamplerWithProperties_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateSamplerWithProperties *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateSamplerWithProperties_EXT});

    vcl_encode_cl_sampler(enc, &args->ret);
    /* skip args->context */
    /* skip args->sampler_properties */
    if (vcl_encode_simple_pointer(enc, args->errcode_ret))
        vcl_encode_cl_int(enc, args->errcode_ret);
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clRetainSampler_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clRetainSampler *args)
{
    vcl_decode_cl_sampler_lookup(dec, &args->sampler);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clRetainSampler_args_handle(struct vcl_command_clRetainSampler *args)
{
    vcl_replace_cl_sampler_handle(&args->sampler);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clRetainSampler_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clRetainSampler *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clRetainSampler_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->sampler */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clCreateProgramWithSource_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateProgramWithSource *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_uint(dec, &args->count);
    if (vcl_decode_simple_pointer(dec)) {
        args->strings = vcl_cs_decoder_alloc_temp(dec, sizeof(**args->strings));
        if (!args->strings) return;
        vcl_decode_char(dec, *(char **)args->strings);
    } else {
        args->strings = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->lengths = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->lengths));
        if (!args->lengths) return;
        vcl_decode_size_t(dec, (size_t *)args->lengths);
    } else {
        args->lengths = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->errcode_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->errcode_ret));
        if (!args->errcode_ret) return;
    } else {
        args->errcode_ret = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clCreateProgramWithSource_args_handle(struct vcl_command_clCreateProgramWithSource *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->count */
    /* skip args->strings */
    /* skip args->lengths */
    /* skip args->errcode_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clCreateProgramWithSource_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateProgramWithSource *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateProgramWithSource_EXT});

    vcl_encode_cl_program(enc, &args->ret);
    /* skip args->context */
    /* skip args->count */
    /* skip args->strings */
    /* skip args->lengths */
    if (vcl_encode_simple_pointer(enc, args->errcode_ret))
        vcl_encode_cl_int(enc, args->errcode_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_decode_clCreateProgramWithBuiltInKernels_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateProgramWithBuiltInKernels *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_uint(dec, &args->num_devices);
    if (vcl_decode_simple_pointer(dec)) {
        args->device_list = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->device_list));
        if (!args->device_list) return;
        vcl_decode_cl_device_id_lookup(dec, (cl_device_id *)args->device_list);
    } else {
        args->device_list = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->kernel_names = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->kernel_names));
        if (!args->kernel_names) return;
        vcl_decode_char(dec, (char *)args->kernel_names);
    } else {
        args->kernel_names = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->errcode_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->errcode_ret));
        if (!args->errcode_ret) return;
    } else {
        args->errcode_ret = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_replace_clCreateProgramWithBuiltInKernels_args_handle(struct vcl_command_clCreateProgramWithBuiltInKernels *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->num_devices */
    if (args->device_list)
        vcl_replace_cl_device_id_handle((cl_device_id *)args->device_list);
    /* skip args->kernel_names */
    /* skip args->errcode_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_encode_clCreateProgramWithBuiltInKernels_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateProgramWithBuiltInKernels *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateProgramWithBuiltInKernels_EXT});

    vcl_encode_cl_program(enc, &args->ret);
    /* skip args->context */
    /* skip args->num_devices */
    /* skip args->device_list */
    /* skip args->kernel_names */
    if (vcl_encode_simple_pointer(enc, args->errcode_ret))
        vcl_encode_cl_int(enc, args->errcode_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clRetainProgram_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clRetainProgram *args)
{
    vcl_decode_cl_program_lookup(dec, &args->program);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clRetainProgram_args_handle(struct vcl_command_clRetainProgram *args)
{
    vcl_replace_cl_program_handle(&args->program);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clRetainProgram_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clRetainProgram *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clRetainProgram_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->program */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_decode_clUnloadPlatformCompiler_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clUnloadPlatformCompiler *args)
{
    vcl_decode_cl_platform_id_lookup(dec, &args->platform);
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_replace_clUnloadPlatformCompiler_args_handle(struct vcl_command_clUnloadPlatformCompiler *args)
{
    vcl_replace_cl_platform_id_handle(&args->platform);
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_encode_clUnloadPlatformCompiler_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clUnloadPlatformCompiler *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clUnloadPlatformCompiler_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->platform */
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clCreateKernel_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateKernel *args)
{
    vcl_decode_cl_program_lookup(dec, &args->program);
    if (vcl_decode_simple_pointer(dec)) {
        args->kernel_name = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->kernel_name));
        if (!args->kernel_name) return;
        vcl_decode_char(dec, (char *)args->kernel_name);
    } else {
        args->kernel_name = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->errcode_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->errcode_ret));
        if (!args->errcode_ret) return;
    } else {
        args->errcode_ret = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clCreateKernel_args_handle(struct vcl_command_clCreateKernel *args)
{
    vcl_replace_cl_program_handle(&args->program);
    /* skip args->kernel_name */
    /* skip args->errcode_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clCreateKernel_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateKernel *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateKernel_EXT});

    vcl_encode_cl_kernel(enc, &args->ret);
    /* skip args->program */
    /* skip args->kernel_name */
    if (vcl_encode_simple_pointer(enc, args->errcode_ret))
        vcl_encode_cl_int(enc, args->errcode_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_decode_clCloneKernel_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCloneKernel *args)
{
    vcl_decode_cl_kernel_lookup(dec, &args->source_kernel);
    if (vcl_decode_simple_pointer(dec)) {
        args->errcode_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->errcode_ret));
        if (!args->errcode_ret) return;
    } else {
        args->errcode_ret = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_replace_clCloneKernel_args_handle(struct vcl_command_clCloneKernel *args)
{
    vcl_replace_cl_kernel_handle(&args->source_kernel);
    /* skip args->errcode_ret */
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_encode_clCloneKernel_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCloneKernel *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCloneKernel_EXT});

    vcl_encode_cl_kernel(enc, &args->ret);
    /* skip args->source_kernel */
    if (vcl_encode_simple_pointer(enc, args->errcode_ret))
        vcl_encode_cl_int(enc, args->errcode_ret);
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clRetainKernel_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clRetainKernel *args)
{
    vcl_decode_cl_kernel_lookup(dec, &args->kernel);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clRetainKernel_args_handle(struct vcl_command_clRetainKernel *args)
{
    vcl_replace_cl_kernel_handle(&args->kernel);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clRetainKernel_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clRetainKernel *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clRetainKernel_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->kernel */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_decode_clCreateUserEvent_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateUserEvent *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    if (vcl_decode_simple_pointer(dec)) {
        args->errcode_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->errcode_ret));
        if (!args->errcode_ret) return;
    } else {
        args->errcode_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_1

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_replace_clCreateUserEvent_args_handle(struct vcl_command_clCreateUserEvent *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->errcode_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_1

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_encode_clCreateUserEvent_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateUserEvent *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateUserEvent_EXT});

    vcl_encode_cl_event(enc, &args->ret);
    /* skip args->context */
    if (vcl_encode_simple_pointer(enc, args->errcode_ret))
        vcl_encode_cl_int(enc, args->errcode_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_1

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clRetainEvent_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clRetainEvent *args)
{
    vcl_decode_cl_event_lookup(dec, &args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clRetainEvent_args_handle(struct vcl_command_clRetainEvent *args)
{
    vcl_replace_cl_event_handle(&args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clRetainEvent_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clRetainEvent *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clRetainEvent_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clEnqueueNDRangeKernel_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueNDRangeKernel *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_kernel_lookup(dec, &args->kernel);
    vcl_decode_cl_uint(dec, &args->work_dim);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->work_dim);
        args->global_work_offset = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->global_work_offset), array_size);
        if (!args->global_work_offset) return;
        vcl_decode_size_t_array(dec, (size_t *)args->global_work_offset, array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->global_work_offset = NULL;
    }
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->work_dim);
        args->global_work_size = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->global_work_size), array_size);
        if (!args->global_work_size) return;
        vcl_decode_size_t_array(dec, (size_t *)args->global_work_size, array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->global_work_size = NULL;
    }
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->work_dim);
        args->local_work_size = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->local_work_size), array_size);
        if (!args->local_work_size) return;
        vcl_decode_size_t_array(dec, (size_t *)args->local_work_size, array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->local_work_size = NULL;
    }
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clEnqueueNDRangeKernel_args_handle(struct vcl_command_clEnqueueNDRangeKernel *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    vcl_replace_cl_kernel_handle(&args->kernel);
    /* skip args->work_dim */
    /* skip args->global_work_offset */
    /* skip args->global_work_size */
    /* skip args->local_work_size */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clEnqueueNDRangeKernel_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueNDRangeKernel *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueNDRangeKernel_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->kernel */
    /* skip args->work_dim */
    /* skip args->global_work_offset */
    /* skip args->global_work_size */
    /* skip args->local_work_size */
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_decode_clUnloadCompiler_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clUnloadCompiler *args)
{
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_replace_clUnloadCompiler_args_handle(struct vcl_command_clUnloadCompiler *args)
{
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_encode_clUnloadCompiler_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clUnloadCompiler *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clUnloadCompiler_EXT});

    vcl_encode_cl_int(enc, &args->ret);
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
static inline void vcl_decode_clCreateCommandQueue_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateCommandQueue *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_device_id_lookup(dec, &args->device);
    vcl_decode_cl_command_queue_properties(dec, &args->properties);
    if (vcl_decode_simple_pointer(dec)) {
        args->errcode_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->errcode_ret));
        if (!args->errcode_ret) return;
    } else {
        args->errcode_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
static inline void vcl_replace_clCreateCommandQueue_args_handle(struct vcl_command_clCreateCommandQueue *args)
{
    vcl_replace_cl_context_handle(&args->context);
    vcl_replace_cl_device_id_handle(&args->device);
    /* skip args->properties */
    /* skip args->errcode_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
static inline void vcl_encode_clCreateCommandQueue_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateCommandQueue *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateCommandQueue_EXT});

    vcl_encode_cl_command_queue(enc, &args->ret);
    /* skip args->context */
    /* skip args->device */
    /* skip args->properties */
    if (vcl_encode_simple_pointer(enc, args->errcode_ret))
        vcl_encode_cl_int(enc, args->errcode_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
static inline void vcl_decode_clCreateSampler_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateSampler *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_bool(dec, &args->normalized_coords);
    vcl_decode_cl_addressing_mode(dec, &args->addressing_mode);
    vcl_decode_cl_filter_mode(dec, &args->filter_mode);
    if (vcl_decode_simple_pointer(dec)) {
        args->errcode_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->errcode_ret));
        if (!args->errcode_ret) return;
    } else {
        args->errcode_ret = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
static inline void vcl_replace_clCreateSampler_args_handle(struct vcl_command_clCreateSampler *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->normalized_coords */
    /* skip args->addressing_mode */
    /* skip args->filter_mode */
    /* skip args->errcode_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
static inline void vcl_encode_clCreateSampler_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateSampler *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateSampler_EXT});

    vcl_encode_cl_sampler(enc, &args->ret);
    /* skip args->context */
    /* skip args->normalized_coords */
    /* skip args->addressing_mode */
    /* skip args->filter_mode */
    if (vcl_encode_simple_pointer(enc, args->errcode_ret))
        vcl_encode_cl_int(enc, args->errcode_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED


static inline void vcl_dispatch_clCreateSubDevices(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2
    struct vcl_command_clCreateSubDevices args;

    if (!ctx->dispatch_clCreateSubDevices) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateSubDevices_args_temp(ctx->decoder, &args);
    if (!args.in_device) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateSubDevices(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateSubDevices returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateSubDevices_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2 not available for clCreateSubDevices");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2
}


static inline void vcl_dispatch_clRetainDevice(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2
    struct vcl_command_clRetainDevice args;

    if (!ctx->dispatch_clRetainDevice) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clRetainDevice_args_temp(ctx->decoder, &args);
    if (!args.device) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clRetainDevice(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clRetainDevice returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clRetainDevice_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2 not available for clRetainDevice");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2
}


static inline void vcl_dispatch_clReleaseDevice(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2
    struct vcl_command_clReleaseDevice args;

    if (!ctx->dispatch_clReleaseDevice) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clReleaseDevice_args_temp(ctx->decoder, &args);
    if (!args.device) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clReleaseDevice(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clReleaseDevice returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clReleaseDevice_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2 not available for clReleaseDevice");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2
}


static inline void vcl_dispatch_clGetDeviceAndHostTimer(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_2_1
    struct vcl_command_clGetDeviceAndHostTimer args;

    if (!ctx->dispatch_clGetDeviceAndHostTimer) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetDeviceAndHostTimer_args_temp(ctx->decoder, &args);
    if (!args.device) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetDeviceAndHostTimer(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetDeviceAndHostTimer returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetDeviceAndHostTimer_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_2_1 not available for clGetDeviceAndHostTimer");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_2_1
}


static inline void vcl_dispatch_clGetHostTimer(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_2_1
    struct vcl_command_clGetHostTimer args;

    if (!ctx->dispatch_clGetHostTimer) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetHostTimer_args_temp(ctx->decoder, &args);
    if (!args.device) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetHostTimer(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetHostTimer returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetHostTimer_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_2_1 not available for clGetHostTimer");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_2_1
}


static inline void vcl_dispatch_clCreateContext(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clCreateContext args;

    if (!ctx->dispatch_clCreateContext) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateContext_args_temp(ctx->decoder, &args);

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateContext(ctx, &args);

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateContext_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clCreateContext");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clCreateContextFromType(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clCreateContextFromType args;

    if (!ctx->dispatch_clCreateContextFromType) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateContextFromType_args_temp(ctx->decoder, &args);

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateContextFromType(ctx, &args);

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateContextFromType_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clCreateContextFromType");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clCreateCommandQueueWithProperties(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_2_0
    struct vcl_command_clCreateCommandQueueWithProperties args;

    if (!ctx->dispatch_clCreateCommandQueueWithProperties) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateCommandQueueWithProperties_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateCommandQueueWithProperties(ctx, &args);

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateCommandQueueWithProperties_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_2_0 not available for clCreateCommandQueueWithProperties");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_2_0
}


static inline void vcl_dispatch_clRetainCommandQueue(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clRetainCommandQueue args;

    if (!ctx->dispatch_clRetainCommandQueue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clRetainCommandQueue_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clRetainCommandQueue(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clRetainCommandQueue returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clRetainCommandQueue_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clRetainCommandQueue");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clCreatePipe(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_2_0
    struct vcl_command_clCreatePipe args;

    if (!ctx->dispatch_clCreatePipe) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreatePipe_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreatePipe(ctx, &args);

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreatePipe_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_2_0 not available for clCreatePipe");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_2_0
}


static inline void vcl_dispatch_clRetainMemObject(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clRetainMemObject args;

    if (!ctx->dispatch_clRetainMemObject) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clRetainMemObject_args_temp(ctx->decoder, &args);
    if (!args.memobj) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clRetainMemObject(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clRetainMemObject returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clRetainMemObject_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clRetainMemObject");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clCreateSamplerWithProperties(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_2_0
    struct vcl_command_clCreateSamplerWithProperties args;

    if (!ctx->dispatch_clCreateSamplerWithProperties) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateSamplerWithProperties_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateSamplerWithProperties(ctx, &args);

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateSamplerWithProperties_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_2_0 not available for clCreateSamplerWithProperties");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_2_0
}


static inline void vcl_dispatch_clRetainSampler(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clRetainSampler args;

    if (!ctx->dispatch_clRetainSampler) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clRetainSampler_args_temp(ctx->decoder, &args);
    if (!args.sampler) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clRetainSampler(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clRetainSampler returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clRetainSampler_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clRetainSampler");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clCreateProgramWithSource(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clCreateProgramWithSource args;

    if (!ctx->dispatch_clCreateProgramWithSource) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateProgramWithSource_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateProgramWithSource(ctx, &args);

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateProgramWithSource_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clCreateProgramWithSource");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clCreateProgramWithBuiltInKernels(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2
    struct vcl_command_clCreateProgramWithBuiltInKernels args;

    if (!ctx->dispatch_clCreateProgramWithBuiltInKernels) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateProgramWithBuiltInKernels_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateProgramWithBuiltInKernels(ctx, &args);

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateProgramWithBuiltInKernels_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2 not available for clCreateProgramWithBuiltInKernels");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2
}


static inline void vcl_dispatch_clRetainProgram(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clRetainProgram args;

    if (!ctx->dispatch_clRetainProgram) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clRetainProgram_args_temp(ctx->decoder, &args);
    if (!args.program) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clRetainProgram(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clRetainProgram returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clRetainProgram_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clRetainProgram");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clUnloadPlatformCompiler(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2
    struct vcl_command_clUnloadPlatformCompiler args;

    if (!ctx->dispatch_clUnloadPlatformCompiler) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clUnloadPlatformCompiler_args_temp(ctx->decoder, &args);
    if (!args.platform) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clUnloadPlatformCompiler(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clUnloadPlatformCompiler returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clUnloadPlatformCompiler_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2 not available for clUnloadPlatformCompiler");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2
}


static inline void vcl_dispatch_clCreateKernel(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clCreateKernel args;

    if (!ctx->dispatch_clCreateKernel) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateKernel_args_temp(ctx->decoder, &args);
    if (!args.program) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateKernel(ctx, &args);

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateKernel_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clCreateKernel");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clCloneKernel(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_2_1
    struct vcl_command_clCloneKernel args;

    if (!ctx->dispatch_clCloneKernel) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCloneKernel_args_temp(ctx->decoder, &args);
    if (!args.source_kernel) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCloneKernel(ctx, &args);

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCloneKernel_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_2_1 not available for clCloneKernel");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_2_1
}


static inline void vcl_dispatch_clRetainKernel(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clRetainKernel args;

    if (!ctx->dispatch_clRetainKernel) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clRetainKernel_args_temp(ctx->decoder, &args);
    if (!args.kernel) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clRetainKernel(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clRetainKernel returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clRetainKernel_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clRetainKernel");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clCreateUserEvent(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_1
    struct vcl_command_clCreateUserEvent args;

    if (!ctx->dispatch_clCreateUserEvent) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateUserEvent_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateUserEvent(ctx, &args);

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateUserEvent_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_1 not available for clCreateUserEvent");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_1
}


static inline void vcl_dispatch_clRetainEvent(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clRetainEvent args;

    if (!ctx->dispatch_clRetainEvent) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clRetainEvent_args_temp(ctx->decoder, &args);
    if (!args.event) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clRetainEvent(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clRetainEvent returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clRetainEvent_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clRetainEvent");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clEnqueueNDRangeKernel(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clEnqueueNDRangeKernel args;

    if (!ctx->dispatch_clEnqueueNDRangeKernel) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueNDRangeKernel_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueNDRangeKernel(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueNDRangeKernel returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueNDRangeKernel_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clEnqueueNDRangeKernel");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clUnloadCompiler(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
    struct vcl_command_clUnloadCompiler args;

    if (!ctx->dispatch_clUnloadCompiler) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clUnloadCompiler_args_temp(ctx->decoder, &args);

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clUnloadCompiler(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clUnloadCompiler returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clUnloadCompiler_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_1_DEPRECATED not available for clUnloadCompiler");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED
}


static inline void vcl_dispatch_clCreateCommandQueue(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
    struct vcl_command_clCreateCommandQueue args;

    if (!ctx->dispatch_clCreateCommandQueue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateCommandQueue_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateCommandQueue(ctx, &args);

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateCommandQueue_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2_DEPRECATED not available for clCreateCommandQueue");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED
}


static inline void vcl_dispatch_clCreateSampler(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
    struct vcl_command_clCreateSampler args;

    if (!ctx->dispatch_clCreateSampler) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateSampler_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateSampler(ctx, &args);

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateSampler_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2_DEPRECATED not available for clCreateSampler");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED
}

#pragma GCC diagnostic pop

#endif /* VCL_PROTOCOL_RENDERER_DUMMY_H */
