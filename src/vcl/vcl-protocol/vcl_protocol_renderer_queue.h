/* This file is generated by vcl-protocol.  See vcl_protocol_renderer.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#ifndef VCL_PROTOCOL_RENDERER_QUEUE_H
#define VCL_PROTOCOL_RENDERER_QUEUE_H

#include "vcl_protocol_renderer_structs.h"

#pragma GCC diagnostic push
#if !defined(__clang__) && defined(__GNUC__) && __GNUC__ >= 12
#pragma GCC diagnostic ignored "-Wdangling-pointer"
#endif
#pragma GCC diagnostic ignored "-Wpointer-arith"
#pragma GCC diagnostic ignored "-Wunused-parameter"

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_decode_clSetDefaultDeviceCommandQueue_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clSetDefaultDeviceCommandQueue *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_device_id_lookup(dec, &args->device);
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_replace_clSetDefaultDeviceCommandQueue_args_handle(struct vcl_command_clSetDefaultDeviceCommandQueue *args)
{
    vcl_replace_cl_context_handle(&args->context);
    vcl_replace_cl_device_id_handle(&args->device);
    vcl_replace_cl_command_queue_handle(&args->command_queue);
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_encode_clSetDefaultDeviceCommandQueue_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clSetDefaultDeviceCommandQueue *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clSetDefaultDeviceCommandQueue_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    /* skip args->device */
    /* skip args->command_queue */
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clReleaseCommandQueue_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clReleaseCommandQueue *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clReleaseCommandQueue_args_handle(struct vcl_command_clReleaseCommandQueue *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clReleaseCommandQueue_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clReleaseCommandQueue *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clReleaseCommandQueue_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clGetCommandQueueInfo_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetCommandQueueInfo *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_command_queue_info(dec, &args->param_name);
    vcl_decode_size_t(dec, &args->param_value_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->param_value_size);
        args->param_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->param_value) return;
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->param_value = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->param_value_size_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->param_value_size_ret));
        if (!args->param_value_size_ret) return;
    } else {
        args->param_value_size_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clGetCommandQueueInfo_args_handle(struct vcl_command_clGetCommandQueueInfo *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    /* skip args->param_name */
    /* skip args->param_value_size */
    /* skip args->param_value */
    /* skip args->param_value_size_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clGetCommandQueueInfo_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetCommandQueueInfo *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetCommandQueueInfo_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->param_name */
    /* skip args->param_value_size */
    if (args->param_value) {
        vcl_encode_array_size(enc, args->param_value_size);
        vcl_encode_blob_array(enc, args->param_value, args->param_value_size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->param_value_size_ret))
        vcl_encode_size_t(enc, args->param_value_size_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clFlush_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clFlush *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clFlush_args_handle(struct vcl_command_clFlush *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clFlush_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clFlush *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clFlush_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clFinish_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clFinish *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clFinish_args_handle(struct vcl_command_clFinish *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clFinish_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clFinish *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clFinish_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0_DEPRECATED
static inline void vcl_decode_clSetCommandQueueProperty_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clSetCommandQueueProperty *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_command_queue_properties(dec, &args->properties);
    vcl_decode_cl_bool(dec, &args->enable);
    if (vcl_decode_simple_pointer(dec)) {
        args->old_properties = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->old_properties));
        if (!args->old_properties) return;
    } else {
        args->old_properties = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_0_DEPRECATED
static inline void vcl_replace_clSetCommandQueueProperty_args_handle(struct vcl_command_clSetCommandQueueProperty *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    /* skip args->properties */
    /* skip args->enable */
    /* skip args->old_properties */
}
#endif // CL_API_SUFFIX__VERSION_1_0_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_0_DEPRECATED
static inline void vcl_encode_clSetCommandQueueProperty_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clSetCommandQueueProperty *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clSetCommandQueueProperty_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->properties */
    /* skip args->enable */
    if (vcl_encode_simple_pointer(enc, args->old_properties))
        vcl_encode_cl_command_queue_properties(enc, args->old_properties);
}
#endif // CL_API_SUFFIX__VERSION_1_0_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_decode_clEnqueueMarker_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueMarker *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_replace_clEnqueueMarker_args_handle(struct vcl_command_clEnqueueMarker *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_encode_clEnqueueMarker_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueMarker *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueMarker_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_decode_clEnqueueBarrier_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueBarrier *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_replace_clEnqueueBarrier_args_handle(struct vcl_command_clEnqueueBarrier *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_encode_clEnqueueBarrier_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueBarrier *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueBarrier_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
static inline void vcl_decode_clCreateCommandQueueMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateCommandQueueMESA *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_device_id_lookup(dec, &args->device);
    vcl_decode_cl_command_queue_properties(dec, &args->properties);
    if (vcl_decode_simple_pointer(dec)) {
        args->queue = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->queue));
        if (!args->queue) return;
        vcl_decode_cl_command_queue_temp(dec, args->queue);
    } else {
        args->queue = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
static inline void vcl_replace_clCreateCommandQueueMESA_args_handle(struct vcl_command_clCreateCommandQueueMESA *args)
{
    vcl_replace_cl_context_handle(&args->context);
    vcl_replace_cl_device_id_handle(&args->device);
    /* skip args->properties */
    /* skip args->queue */
}
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
static inline void vcl_encode_clCreateCommandQueueMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateCommandQueueMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateCommandQueueMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    /* skip args->device */
    /* skip args->properties */
    if (vcl_encode_simple_pointer(enc, args->queue))
        vcl_encode_cl_command_queue(enc, args->queue);
}
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_decode_clCreateCommandQueueWithPropertiesMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateCommandQueueWithPropertiesMESA *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_device_id_lookup(dec, &args->device);
    vcl_decode_size_t(dec, &args->properties_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->properties_size);
        args->properties = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->properties), array_size);
        if (!args->properties) return;
        vcl_decode_cl_queue_properties_array(dec, (cl_queue_properties *)args->properties, array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->properties = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->queue = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->queue));
        if (!args->queue) return;
        vcl_decode_cl_command_queue_temp(dec, args->queue);
    } else {
        args->queue = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_replace_clCreateCommandQueueWithPropertiesMESA_args_handle(struct vcl_command_clCreateCommandQueueWithPropertiesMESA *args)
{
    vcl_replace_cl_context_handle(&args->context);
    vcl_replace_cl_device_id_handle(&args->device);
    /* skip args->properties_size */
    /* skip args->properties */
    /* skip args->queue */
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_encode_clCreateCommandQueueWithPropertiesMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateCommandQueueWithPropertiesMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateCommandQueueWithPropertiesMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    /* skip args->device */
    /* skip args->properties_size */
    /* skip args->properties */
    if (vcl_encode_simple_pointer(enc, args->queue))
        vcl_encode_cl_command_queue(enc, args->queue);
}
#endif // CL_API_SUFFIX__VERSION_2_0


static inline void vcl_dispatch_clSetDefaultDeviceCommandQueue(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_2_1
    struct vcl_command_clSetDefaultDeviceCommandQueue args;

    if (!ctx->dispatch_clSetDefaultDeviceCommandQueue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clSetDefaultDeviceCommandQueue_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clSetDefaultDeviceCommandQueue(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clSetDefaultDeviceCommandQueue returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clSetDefaultDeviceCommandQueue_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_2_1 not available for clSetDefaultDeviceCommandQueue");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_2_1
}


static inline void vcl_dispatch_clReleaseCommandQueue(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clReleaseCommandQueue args;

    if (!ctx->dispatch_clReleaseCommandQueue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clReleaseCommandQueue_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clReleaseCommandQueue(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clReleaseCommandQueue returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clReleaseCommandQueue_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clReleaseCommandQueue");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clGetCommandQueueInfo(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clGetCommandQueueInfo args;

    if (!ctx->dispatch_clGetCommandQueueInfo) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetCommandQueueInfo_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetCommandQueueInfo(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetCommandQueueInfo returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetCommandQueueInfo_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clGetCommandQueueInfo");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clFlush(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clFlush args;

    if (!ctx->dispatch_clFlush) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clFlush_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clFlush(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clFlush returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clFlush_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clFlush");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clFinish(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clFinish args;

    if (!ctx->dispatch_clFinish) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clFinish_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clFinish(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clFinish returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clFinish_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clFinish");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clSetCommandQueueProperty(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0_DEPRECATED
    struct vcl_command_clSetCommandQueueProperty args;

    if (!ctx->dispatch_clSetCommandQueueProperty) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clSetCommandQueueProperty_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clSetCommandQueueProperty(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clSetCommandQueueProperty returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clSetCommandQueueProperty_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0_DEPRECATED not available for clSetCommandQueueProperty");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0_DEPRECATED
}


static inline void vcl_dispatch_clEnqueueMarker(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
    struct vcl_command_clEnqueueMarker args;

    if (!ctx->dispatch_clEnqueueMarker) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueMarker_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueMarker(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueMarker returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueMarker_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_1_DEPRECATED not available for clEnqueueMarker");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED
}


static inline void vcl_dispatch_clEnqueueBarrier(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
    struct vcl_command_clEnqueueBarrier args;

    if (!ctx->dispatch_clEnqueueBarrier) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueBarrier_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueBarrier(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueBarrier returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueBarrier_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_1_DEPRECATED not available for clEnqueueBarrier");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED
}


static inline void vcl_dispatch_clCreateCommandQueueMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
    struct vcl_command_clCreateCommandQueueMESA args;

    if (!ctx->dispatch_clCreateCommandQueueMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateCommandQueueMESA_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateCommandQueueMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateCommandQueueMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateCommandQueueMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2_DEPRECATED not available for clCreateCommandQueueMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED
}


static inline void vcl_dispatch_clCreateCommandQueueWithPropertiesMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_2_0
    struct vcl_command_clCreateCommandQueueWithPropertiesMESA args;

    if (!ctx->dispatch_clCreateCommandQueueWithPropertiesMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateCommandQueueWithPropertiesMESA_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateCommandQueueWithPropertiesMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateCommandQueueWithPropertiesMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateCommandQueueWithPropertiesMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_2_0 not available for clCreateCommandQueueWithPropertiesMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_2_0
}

#pragma GCC diagnostic pop

#endif /* VCL_PROTOCOL_RENDERER_QUEUE_H */
