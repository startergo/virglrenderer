/* This file is generated by vcl-protocol.  See vcl_protocol_renderer.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#ifndef VCL_PROTOCOL_RENDERER_MEMORY_H
#define VCL_PROTOCOL_RENDERER_MEMORY_H

#include "vcl_protocol_renderer_structs.h"

#pragma GCC diagnostic push
#if !defined(__clang__) && defined(__GNUC__) && __GNUC__ >= 12
#pragma GCC diagnostic ignored "-Wdangling-pointer"
#endif
#pragma GCC diagnostic ignored "-Wpointer-arith"
#pragma GCC diagnostic ignored "-Wunused-parameter"

/*
 * These structs/unions/commands are not included
 *
 *   clEnqueueReadBufferRect
 *   clEnqueueWriteBufferRect
 */

/* struct cl_image_desc_MESA */

static inline void
vcl_decode_cl_image_desc_MESA_temp(struct vcl_cs_decoder *dec, cl_image_desc_MESA *val)
{
    vcl_decode_cl_mem_object_type(dec, &val->image_type);
    vcl_decode_size_t(dec, &val->image_width);
    vcl_decode_size_t(dec, &val->image_height);
    vcl_decode_size_t(dec, &val->image_depth);
    vcl_decode_size_t(dec, &val->image_array_size);
    vcl_decode_size_t(dec, &val->image_row_pitch);
    vcl_decode_size_t(dec, &val->image_slice_pitch);
    vcl_decode_cl_uint(dec, &val->num_mip_levels);
    vcl_decode_cl_uint(dec, &val->num_samples);
    vcl_decode_cl_mem_lookup(dec, &val->mem_object);
}

static inline void
vcl_replace_cl_image_desc_MESA_handle(cl_image_desc_MESA *val)
{
    /* skip val->image_type */
    /* skip val->image_width */
    /* skip val->image_height */
    /* skip val->image_depth */
    /* skip val->image_array_size */
    /* skip val->image_row_pitch */
    /* skip val->image_slice_pitch */
    /* skip val->num_mip_levels */
    /* skip val->num_samples */
    vcl_replace_cl_mem_handle(&val->mem_object);
}

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clReleaseMemObject_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clReleaseMemObject *args)
{
    vcl_decode_cl_mem_lookup(dec, &args->memobj);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clReleaseMemObject_args_handle(struct vcl_command_clReleaseMemObject *args)
{
    vcl_replace_cl_mem_handle(&args->memobj);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clReleaseMemObject_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clReleaseMemObject *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clReleaseMemObject_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->memobj */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clGetSupportedImageFormats_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetSupportedImageFormats *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_mem_flags(dec, &args->flags);
    vcl_decode_cl_mem_object_type(dec, &args->image_type);
    vcl_decode_cl_uint(dec, &args->num_entries);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_entries);
        args->image_formats = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->image_formats), iter_count);
        if (!args->image_formats) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_image_format_partial_temp(dec, &args->image_formats[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->image_formats = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->num_image_formats = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->num_image_formats));
        if (!args->num_image_formats) return;
    } else {
        args->num_image_formats = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clGetSupportedImageFormats_args_handle(struct vcl_command_clGetSupportedImageFormats *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->flags */
    /* skip args->image_type */
    /* skip args->num_entries */
    /* skip args->image_formats */
    /* skip args->num_image_formats */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clGetSupportedImageFormats_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetSupportedImageFormats *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetSupportedImageFormats_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    /* skip args->flags */
    /* skip args->image_type */
    /* skip args->num_entries */
    if (args->image_formats) {
        vcl_encode_array_size(enc, args->num_entries);
        for (cl_uint i = 0; i < args->num_entries; i++)
            vcl_encode_cl_image_format(enc, &args->image_formats[i]);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->num_image_formats))
        vcl_encode_cl_uint(enc, args->num_image_formats);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clGetMemObjectInfo_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetMemObjectInfo *args)
{
    vcl_decode_cl_mem_lookup(dec, &args->memobj);
    vcl_decode_cl_mem_info(dec, &args->param_name);
    vcl_decode_size_t(dec, &args->param_value_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->param_value_size);
        args->param_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->param_value) return;
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->param_value = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->param_value_size_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->param_value_size_ret));
        if (!args->param_value_size_ret) return;
    } else {
        args->param_value_size_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clGetMemObjectInfo_args_handle(struct vcl_command_clGetMemObjectInfo *args)
{
    vcl_replace_cl_mem_handle(&args->memobj);
    /* skip args->param_name */
    /* skip args->param_value_size */
    /* skip args->param_value */
    /* skip args->param_value_size_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clGetMemObjectInfo_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetMemObjectInfo *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetMemObjectInfo_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->memobj */
    /* skip args->param_name */
    /* skip args->param_value_size */
    if (args->param_value) {
        vcl_encode_array_size(enc, args->param_value_size);
        vcl_encode_blob_array(enc, args->param_value, args->param_value_size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->param_value_size_ret))
        vcl_encode_size_t(enc, args->param_value_size_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clGetImageInfo_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetImageInfo *args)
{
    vcl_decode_cl_mem_lookup(dec, &args->image);
    vcl_decode_cl_image_info(dec, &args->param_name);
    vcl_decode_size_t(dec, &args->param_value_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->param_value_size);
        args->param_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->param_value) return;
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->param_value = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->param_value_size_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->param_value_size_ret));
        if (!args->param_value_size_ret) return;
    } else {
        args->param_value_size_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clGetImageInfo_args_handle(struct vcl_command_clGetImageInfo *args)
{
    vcl_replace_cl_mem_handle(&args->image);
    /* skip args->param_name */
    /* skip args->param_value_size */
    /* skip args->param_value */
    /* skip args->param_value_size_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clGetImageInfo_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetImageInfo *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetImageInfo_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->image */
    /* skip args->param_name */
    /* skip args->param_value_size */
    if (args->param_value) {
        vcl_encode_array_size(enc, args->param_value_size);
        vcl_encode_blob_array(enc, args->param_value, args->param_value_size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->param_value_size_ret))
        vcl_encode_size_t(enc, args->param_value_size_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clReleaseSampler_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clReleaseSampler *args)
{
    vcl_decode_cl_sampler_lookup(dec, &args->sampler);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clReleaseSampler_args_handle(struct vcl_command_clReleaseSampler *args)
{
    vcl_replace_cl_sampler_handle(&args->sampler);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clReleaseSampler_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clReleaseSampler *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clReleaseSampler_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->sampler */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clGetSamplerInfo_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetSamplerInfo *args)
{
    vcl_decode_cl_sampler_lookup(dec, &args->sampler);
    vcl_decode_cl_sampler_info(dec, &args->param_name);
    vcl_decode_size_t(dec, &args->param_value_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->param_value_size);
        args->param_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->param_value) return;
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->param_value = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->param_value_size_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->param_value_size_ret));
        if (!args->param_value_size_ret) return;
    } else {
        args->param_value_size_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clGetSamplerInfo_args_handle(struct vcl_command_clGetSamplerInfo *args)
{
    vcl_replace_cl_sampler_handle(&args->sampler);
    /* skip args->param_name */
    /* skip args->param_value_size */
    /* skip args->param_value */
    /* skip args->param_value_size_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clGetSamplerInfo_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetSamplerInfo *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetSamplerInfo_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->sampler */
    /* skip args->param_name */
    /* skip args->param_value_size */
    if (args->param_value) {
        vcl_encode_array_size(enc, args->param_value_size);
        vcl_encode_blob_array(enc, args->param_value, args->param_value_size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->param_value_size_ret))
        vcl_encode_size_t(enc, args->param_value_size_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clEnqueueReadBuffer_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueReadBuffer *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_mem_lookup(dec, &args->buffer);
    vcl_decode_cl_bool(dec, &args->blocking_read);
    vcl_decode_size_t(dec, &args->offset);
    vcl_decode_size_t(dec, &args->size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->size);
        args->ptr = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->ptr) return;
    } else {
        vcl_decode_array_size(dec, args->size);
        args->ptr = NULL;
    }
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clEnqueueReadBuffer_args_handle(struct vcl_command_clEnqueueReadBuffer *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    vcl_replace_cl_mem_handle(&args->buffer);
    /* skip args->blocking_read */
    /* skip args->offset */
    /* skip args->size */
    /* skip args->ptr */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clEnqueueReadBuffer_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueReadBuffer *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueReadBuffer_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->buffer */
    /* skip args->blocking_read */
    /* skip args->offset */
    /* skip args->size */
    if (args->ptr) {
        vcl_encode_array_size(enc, args->size);
        vcl_encode_blob_array(enc, args->ptr, args->size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clEnqueueWriteBuffer_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueWriteBuffer *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_mem_lookup(dec, &args->buffer);
    vcl_decode_cl_bool(dec, &args->blocking_write);
    vcl_decode_size_t(dec, &args->offset);
    vcl_decode_size_t(dec, &args->size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->size);
        args->ptr = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->ptr) return;
        vcl_decode_blob_array(dec, (void *)args->ptr, array_size);
    } else {
        vcl_decode_array_size(dec, args->size);
        args->ptr = NULL;
    }
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clEnqueueWriteBuffer_args_handle(struct vcl_command_clEnqueueWriteBuffer *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    vcl_replace_cl_mem_handle(&args->buffer);
    /* skip args->blocking_write */
    /* skip args->offset */
    /* skip args->size */
    /* skip args->ptr */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clEnqueueWriteBuffer_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueWriteBuffer *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueWriteBuffer_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->buffer */
    /* skip args->blocking_write */
    /* skip args->offset */
    /* skip args->size */
    /* skip args->ptr */
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_decode_clEnqueueFillBuffer_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueFillBuffer *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_mem_lookup(dec, &args->buffer);
    vcl_decode_size_t(dec, &args->pattern_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->pattern_size);
        args->pattern = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->pattern) return;
        vcl_decode_blob_array(dec, (void *)args->pattern, array_size);
    } else {
        vcl_decode_array_size(dec, args->pattern_size);
        args->pattern = NULL;
    }
    vcl_decode_size_t(dec, &args->offset);
    vcl_decode_size_t(dec, &args->size);
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_replace_clEnqueueFillBuffer_args_handle(struct vcl_command_clEnqueueFillBuffer *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    vcl_replace_cl_mem_handle(&args->buffer);
    /* skip args->pattern_size */
    /* skip args->pattern */
    /* skip args->offset */
    /* skip args->size */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_encode_clEnqueueFillBuffer_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueFillBuffer *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueFillBuffer_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->buffer */
    /* skip args->pattern_size */
    /* skip args->pattern */
    /* skip args->offset */
    /* skip args->size */
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clEnqueueCopyBuffer_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueCopyBuffer *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_mem_lookup(dec, &args->src_buffer);
    vcl_decode_cl_mem_lookup(dec, &args->dst_buffer);
    vcl_decode_size_t(dec, &args->src_offset);
    vcl_decode_size_t(dec, &args->dst_offset);
    vcl_decode_size_t(dec, &args->size);
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clEnqueueCopyBuffer_args_handle(struct vcl_command_clEnqueueCopyBuffer *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    vcl_replace_cl_mem_handle(&args->src_buffer);
    vcl_replace_cl_mem_handle(&args->dst_buffer);
    /* skip args->src_offset */
    /* skip args->dst_offset */
    /* skip args->size */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clEnqueueCopyBuffer_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueCopyBuffer *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueCopyBuffer_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->src_buffer */
    /* skip args->dst_buffer */
    /* skip args->src_offset */
    /* skip args->dst_offset */
    /* skip args->size */
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_decode_clEnqueueCopyBufferRect_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueCopyBufferRect *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_mem_lookup(dec, &args->src_buffer);
    vcl_decode_cl_mem_lookup(dec, &args->dst_buffer);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, 3);
        args->src_origin = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->src_origin), array_size);
        if (!args->src_origin) return;
        vcl_decode_size_t_array(dec, (size_t *)args->src_origin, array_size);
    } else {
        vcl_decode_array_size(dec, 3);
        args->src_origin = NULL;
    }
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, 3);
        args->dst_origin = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->dst_origin), array_size);
        if (!args->dst_origin) return;
        vcl_decode_size_t_array(dec, (size_t *)args->dst_origin, array_size);
    } else {
        vcl_decode_array_size(dec, 3);
        args->dst_origin = NULL;
    }
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, 3);
        args->region = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->region), array_size);
        if (!args->region) return;
        vcl_decode_size_t_array(dec, (size_t *)args->region, array_size);
    } else {
        vcl_decode_array_size(dec, 3);
        args->region = NULL;
    }
    vcl_decode_size_t(dec, &args->src_row_pitch);
    vcl_decode_size_t(dec, &args->src_slice_pitch);
    vcl_decode_size_t(dec, &args->dst_row_pitch);
    vcl_decode_size_t(dec, &args->dst_slice_pitch);
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_1

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_replace_clEnqueueCopyBufferRect_args_handle(struct vcl_command_clEnqueueCopyBufferRect *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    vcl_replace_cl_mem_handle(&args->src_buffer);
    vcl_replace_cl_mem_handle(&args->dst_buffer);
    /* skip args->src_origin */
    /* skip args->dst_origin */
    /* skip args->region */
    /* skip args->src_row_pitch */
    /* skip args->src_slice_pitch */
    /* skip args->dst_row_pitch */
    /* skip args->dst_slice_pitch */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_1

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_encode_clEnqueueCopyBufferRect_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueCopyBufferRect *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueCopyBufferRect_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->src_buffer */
    /* skip args->dst_buffer */
    /* skip args->src_origin */
    /* skip args->dst_origin */
    /* skip args->region */
    /* skip args->src_row_pitch */
    /* skip args->src_slice_pitch */
    /* skip args->dst_row_pitch */
    /* skip args->dst_slice_pitch */
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_1

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clEnqueueCopyImage_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueCopyImage *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_mem_lookup(dec, &args->src_image);
    vcl_decode_cl_mem_lookup(dec, &args->dst_image);
    if (vcl_decode_simple_pointer(dec)) {
        args->src_origin = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->src_origin));
        if (!args->src_origin) return;
        vcl_decode_size_t(dec, (size_t *)args->src_origin);
    } else {
        args->src_origin = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->dst_origin = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->dst_origin));
        if (!args->dst_origin) return;
        vcl_decode_size_t(dec, (size_t *)args->dst_origin);
    } else {
        args->dst_origin = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->region = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->region));
        if (!args->region) return;
        vcl_decode_size_t(dec, (size_t *)args->region);
    } else {
        args->region = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clEnqueueCopyImage_args_handle(struct vcl_command_clEnqueueCopyImage *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    vcl_replace_cl_mem_handle(&args->src_image);
    vcl_replace_cl_mem_handle(&args->dst_image);
    /* skip args->src_origin */
    /* skip args->dst_origin */
    /* skip args->region */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clEnqueueCopyImage_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueCopyImage *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueCopyImage_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->src_image */
    /* skip args->dst_image */
    /* skip args->src_origin */
    /* skip args->dst_origin */
    /* skip args->region */
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clEnqueueCopyImageToBuffer_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueCopyImageToBuffer *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_mem_lookup(dec, &args->src_image);
    vcl_decode_cl_mem_lookup(dec, &args->dst_buffer);
    if (vcl_decode_simple_pointer(dec)) {
        args->src_origin = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->src_origin));
        if (!args->src_origin) return;
        vcl_decode_size_t(dec, (size_t *)args->src_origin);
    } else {
        args->src_origin = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->region = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->region));
        if (!args->region) return;
        vcl_decode_size_t(dec, (size_t *)args->region);
    } else {
        args->region = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    vcl_decode_size_t(dec, &args->dst_offset);
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clEnqueueCopyImageToBuffer_args_handle(struct vcl_command_clEnqueueCopyImageToBuffer *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    vcl_replace_cl_mem_handle(&args->src_image);
    vcl_replace_cl_mem_handle(&args->dst_buffer);
    /* skip args->src_origin */
    /* skip args->region */
    /* skip args->dst_offset */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clEnqueueCopyImageToBuffer_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueCopyImageToBuffer *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueCopyImageToBuffer_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->src_image */
    /* skip args->dst_buffer */
    /* skip args->src_origin */
    /* skip args->region */
    /* skip args->dst_offset */
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clEnqueueCopyBufferToImage_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueCopyBufferToImage *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_mem_lookup(dec, &args->src_buffer);
    vcl_decode_cl_mem_lookup(dec, &args->dst_image);
    vcl_decode_size_t(dec, &args->src_offset);
    if (vcl_decode_simple_pointer(dec)) {
        args->dst_origin = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->dst_origin));
        if (!args->dst_origin) return;
        vcl_decode_size_t(dec, (size_t *)args->dst_origin);
    } else {
        args->dst_origin = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->region = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->region));
        if (!args->region) return;
        vcl_decode_size_t(dec, (size_t *)args->region);
    } else {
        args->region = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clEnqueueCopyBufferToImage_args_handle(struct vcl_command_clEnqueueCopyBufferToImage *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    vcl_replace_cl_mem_handle(&args->src_buffer);
    vcl_replace_cl_mem_handle(&args->dst_image);
    /* skip args->src_offset */
    /* skip args->dst_origin */
    /* skip args->region */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clEnqueueCopyBufferToImage_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueCopyBufferToImage *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueCopyBufferToImage_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->src_buffer */
    /* skip args->dst_image */
    /* skip args->src_offset */
    /* skip args->dst_origin */
    /* skip args->region */
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_decode_clEnqueueMigrateMemObjects_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueMigrateMemObjects *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_uint(dec, &args->num_mem_objects);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_mem_objects);
        args->mem_objects = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->mem_objects), iter_count);
        if (!args->mem_objects) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_mem_lookup(dec, &((cl_mem *)args->mem_objects)[i]);
    } else {
        vcl_decode_array_size(dec, args->num_mem_objects);
        args->mem_objects = NULL;
    }
    vcl_decode_cl_mem_migration_flags(dec, &args->flags);
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_replace_clEnqueueMigrateMemObjects_args_handle(struct vcl_command_clEnqueueMigrateMemObjects *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    /* skip args->num_mem_objects */
    if (args->mem_objects) {
       for (cl_uint i = 0; i < args->num_mem_objects; i++)
            vcl_replace_cl_mem_handle(&((cl_mem *)args->mem_objects)[i]);
    }
    /* skip args->flags */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_encode_clEnqueueMigrateMemObjects_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueMigrateMemObjects *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueMigrateMemObjects_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->num_mem_objects */
    /* skip args->mem_objects */
    /* skip args->flags */
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clCreateBufferMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateBufferMESA *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_mem_flags(dec, &args->flags);
    vcl_decode_size_t(dec, &args->size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->size);
        args->host_ptr = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->host_ptr) return;
        vcl_decode_blob_array(dec, (void *)args->host_ptr, array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->host_ptr = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->buffer = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->buffer));
        if (!args->buffer) return;
        vcl_decode_cl_mem_temp(dec, args->buffer);
    } else {
        args->buffer = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clCreateBufferMESA_args_handle(struct vcl_command_clCreateBufferMESA *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->flags */
    /* skip args->size */
    /* skip args->host_ptr */
    /* skip args->buffer */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clCreateBufferMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateBufferMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateBufferMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    /* skip args->flags */
    /* skip args->size */
    /* skip args->host_ptr */
    if (vcl_encode_simple_pointer(enc, args->buffer))
        vcl_encode_cl_mem(enc, args->buffer);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_3_0
static inline void vcl_decode_clCreateBufferWithPropertiesMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateBufferWithPropertiesMESA *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    if (vcl_peek_array_size(dec)) {
        const size_t null_terminated_array_size = vcl_decode_array_size_unchecked(dec);
        args->properties = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->properties), null_terminated_array_size);
        if (!args->properties) return;
        vcl_decode_cl_mem_properties_array(dec, (cl_mem_properties *)args->properties, null_terminated_array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->properties = NULL;
    }
    vcl_decode_cl_mem_flags(dec, &args->flags);
    vcl_decode_size_t(dec, &args->size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->size);
        args->host_ptr = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->host_ptr) return;
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->host_ptr = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->buffer = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->buffer));
        if (!args->buffer) return;
        vcl_decode_cl_mem_temp(dec, args->buffer);
    } else {
        args->buffer = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_3_0

#ifdef CL_API_SUFFIX__VERSION_3_0
static inline void vcl_replace_clCreateBufferWithPropertiesMESA_args_handle(struct vcl_command_clCreateBufferWithPropertiesMESA *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->properties */
    /* skip args->flags */
    /* skip args->size */
    /* skip args->host_ptr */
    /* skip args->buffer */
}
#endif // CL_API_SUFFIX__VERSION_3_0

#ifdef CL_API_SUFFIX__VERSION_3_0
static inline void vcl_encode_clCreateBufferWithPropertiesMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateBufferWithPropertiesMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateBufferWithPropertiesMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    /* skip args->properties */
    /* skip args->flags */
    /* skip args->size */
    if (args->host_ptr) {
        vcl_encode_array_size(enc, args->size);
        vcl_encode_blob_array(enc, args->host_ptr, args->size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->buffer))
        vcl_encode_cl_mem(enc, args->buffer);
}
#endif // CL_API_SUFFIX__VERSION_3_0

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_decode_clCreateImage2DMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateImage2DMESA *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_mem_flags(dec, &args->flags);
    if (vcl_decode_simple_pointer(dec)) {
        args->image_format = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->image_format));
        if (!args->image_format) return;
        vcl_decode_cl_image_format_temp(dec, (cl_image_format *)args->image_format);
    } else {
        args->image_format = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    vcl_decode_size_t(dec, &args->image_width);
    vcl_decode_size_t(dec, &args->image_height);
    vcl_decode_size_t(dec, &args->image_row_pitch);
    vcl_decode_size_t(dec, &args->size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->size);
        args->host_ptr = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->host_ptr) return;
        vcl_decode_blob_array(dec, (void *)args->host_ptr, array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->host_ptr = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->image = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->image));
        if (!args->image) return;
        vcl_decode_cl_mem_temp(dec, args->image);
    } else {
        args->image = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_replace_clCreateImage2DMESA_args_handle(struct vcl_command_clCreateImage2DMESA *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->flags */
    if (args->image_format)
        vcl_replace_cl_image_format_handle((cl_image_format *)args->image_format);
    /* skip args->image_width */
    /* skip args->image_height */
    /* skip args->image_row_pitch */
    /* skip args->size */
    /* skip args->host_ptr */
    /* skip args->image */
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_encode_clCreateImage2DMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateImage2DMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateImage2DMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    /* skip args->flags */
    /* skip args->image_format */
    /* skip args->image_width */
    /* skip args->image_height */
    /* skip args->image_row_pitch */
    /* skip args->size */
    /* skip args->host_ptr */
    if (vcl_encode_simple_pointer(enc, args->image))
        vcl_encode_cl_mem(enc, args->image);
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_decode_clCreateImage3DMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateImage3DMESA *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_mem_flags(dec, &args->flags);
    if (vcl_decode_simple_pointer(dec)) {
        args->image_format = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->image_format));
        if (!args->image_format) return;
        vcl_decode_cl_image_format_temp(dec, (cl_image_format *)args->image_format);
    } else {
        args->image_format = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    vcl_decode_size_t(dec, &args->image_width);
    vcl_decode_size_t(dec, &args->image_height);
    vcl_decode_size_t(dec, &args->image_depth);
    vcl_decode_size_t(dec, &args->image_row_pitch);
    vcl_decode_size_t(dec, &args->image_slice_pitch);
    vcl_decode_size_t(dec, &args->size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->size);
        args->host_ptr = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->host_ptr) return;
        vcl_decode_blob_array(dec, (void *)args->host_ptr, array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->host_ptr = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->image = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->image));
        if (!args->image) return;
        vcl_decode_cl_mem_temp(dec, args->image);
    } else {
        args->image = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_replace_clCreateImage3DMESA_args_handle(struct vcl_command_clCreateImage3DMESA *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->flags */
    if (args->image_format)
        vcl_replace_cl_image_format_handle((cl_image_format *)args->image_format);
    /* skip args->image_width */
    /* skip args->image_height */
    /* skip args->image_depth */
    /* skip args->image_row_pitch */
    /* skip args->image_slice_pitch */
    /* skip args->size */
    /* skip args->host_ptr */
    /* skip args->image */
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_encode_clCreateImage3DMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateImage3DMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateImage3DMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    /* skip args->flags */
    /* skip args->image_format */
    /* skip args->image_width */
    /* skip args->image_height */
    /* skip args->image_depth */
    /* skip args->image_row_pitch */
    /* skip args->image_slice_pitch */
    /* skip args->size */
    /* skip args->host_ptr */
    if (vcl_encode_simple_pointer(enc, args->image))
        vcl_encode_cl_mem(enc, args->image);
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
static inline void vcl_decode_clCreateSamplerMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateSamplerMESA *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_bool(dec, &args->normalized_coords);
    vcl_decode_cl_addressing_mode(dec, &args->addressing_mode);
    vcl_decode_cl_filter_mode(dec, &args->filter_mode);
    if (vcl_decode_simple_pointer(dec)) {
        args->sampler = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->sampler));
        if (!args->sampler) return;
        vcl_decode_cl_sampler_temp(dec, args->sampler);
    } else {
        args->sampler = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
static inline void vcl_replace_clCreateSamplerMESA_args_handle(struct vcl_command_clCreateSamplerMESA *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->normalized_coords */
    /* skip args->addressing_mode */
    /* skip args->filter_mode */
    /* skip args->sampler */
}
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
static inline void vcl_encode_clCreateSamplerMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateSamplerMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateSamplerMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    /* skip args->normalized_coords */
    /* skip args->addressing_mode */
    /* skip args->filter_mode */
    if (vcl_encode_simple_pointer(enc, args->sampler))
        vcl_encode_cl_sampler(enc, args->sampler);
}
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_decode_clCreateSamplerWithPropertiesMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateSamplerWithPropertiesMESA *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    if (vcl_peek_array_size(dec)) {
        const size_t null_terminated_array_size = vcl_decode_array_size_unchecked(dec);
        args->sampler_properties = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->sampler_properties), null_terminated_array_size);
        if (!args->sampler_properties) return;
        vcl_decode_cl_sampler_properties_array(dec, (cl_sampler_properties *)args->sampler_properties, null_terminated_array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->sampler_properties = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->sampler = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->sampler));
        if (!args->sampler) return;
        vcl_decode_cl_sampler_temp(dec, args->sampler);
    } else {
        args->sampler = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_replace_clCreateSamplerWithPropertiesMESA_args_handle(struct vcl_command_clCreateSamplerWithPropertiesMESA *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->sampler_properties */
    /* skip args->sampler */
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_2_0
static inline void vcl_encode_clCreateSamplerWithPropertiesMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateSamplerWithPropertiesMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateSamplerWithPropertiesMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    /* skip args->sampler_properties */
    if (vcl_encode_simple_pointer(enc, args->sampler))
        vcl_encode_cl_sampler(enc, args->sampler);
}
#endif // CL_API_SUFFIX__VERSION_2_0

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_decode_clCreateSubBufferMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateSubBufferMESA *args)
{
    vcl_decode_cl_mem_lookup(dec, &args->buffer);
    vcl_decode_cl_mem_flags(dec, &args->flags);
    vcl_decode_cl_buffer_create_type(dec, &args->buffer_create_type);
    vcl_decode_size_t(dec, &args->buffer_create_info_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->buffer_create_info_size);
        args->buffer_create_info = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->buffer_create_info) return;
        vcl_decode_blob_array(dec, (void *)args->buffer_create_info, array_size);
    } else {
        vcl_decode_array_size(dec, args->buffer_create_info_size);
        args->buffer_create_info = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->sub_buffer = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->sub_buffer));
        if (!args->sub_buffer) return;
        vcl_decode_cl_mem_temp(dec, args->sub_buffer);
    } else {
        args->sub_buffer = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_1

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_replace_clCreateSubBufferMESA_args_handle(struct vcl_command_clCreateSubBufferMESA *args)
{
    vcl_replace_cl_mem_handle(&args->buffer);
    /* skip args->flags */
    /* skip args->buffer_create_type */
    /* skip args->buffer_create_info_size */
    /* skip args->buffer_create_info */
    /* skip args->sub_buffer */
}
#endif // CL_API_SUFFIX__VERSION_1_1

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_encode_clCreateSubBufferMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateSubBufferMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateSubBufferMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->buffer */
    /* skip args->flags */
    /* skip args->buffer_create_type */
    /* skip args->buffer_create_info_size */
    /* skip args->buffer_create_info */
    if (vcl_encode_simple_pointer(enc, args->sub_buffer))
        vcl_encode_cl_mem(enc, args->sub_buffer);
}
#endif // CL_API_SUFFIX__VERSION_1_1

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_decode_clCreateImageMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateImageMESA *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_mem_flags(dec, &args->flags);
    if (vcl_decode_simple_pointer(dec)) {
        args->image_format = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->image_format));
        if (!args->image_format) return;
        vcl_decode_cl_image_format_temp(dec, (cl_image_format *)args->image_format);
    } else {
        args->image_format = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->image_desc = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->image_desc));
        if (!args->image_desc) return;
        vcl_decode_cl_image_desc_MESA_temp(dec, (cl_image_desc_MESA *)args->image_desc);
    } else {
        args->image_desc = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    vcl_decode_size_t(dec, &args->size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->size);
        args->host_ptr = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->host_ptr) return;
        vcl_decode_blob_array(dec, (void *)args->host_ptr, array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->host_ptr = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->image = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->image));
        if (!args->image) return;
        vcl_decode_cl_mem_temp(dec, args->image);
    } else {
        args->image = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_replace_clCreateImageMESA_args_handle(struct vcl_command_clCreateImageMESA *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->flags */
    if (args->image_format)
        vcl_replace_cl_image_format_handle((cl_image_format *)args->image_format);
    if (args->image_desc)
        vcl_replace_cl_image_desc_MESA_handle((cl_image_desc_MESA *)args->image_desc);
    /* skip args->size */
    /* skip args->host_ptr */
    /* skip args->image */
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_encode_clCreateImageMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateImageMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateImageMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    /* skip args->flags */
    /* skip args->image_format */
    /* skip args->image_desc */
    /* skip args->size */
    /* skip args->host_ptr */
    if (vcl_encode_simple_pointer(enc, args->image))
        vcl_encode_cl_mem(enc, args->image);
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_3_0
static inline void vcl_decode_clCreateImageWithPropertiesMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateImageWithPropertiesMESA *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    if (vcl_peek_array_size(dec)) {
        const size_t null_terminated_array_size = vcl_decode_array_size_unchecked(dec);
        args->properties = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->properties), null_terminated_array_size);
        if (!args->properties) return;
        vcl_decode_cl_mem_properties_array(dec, (cl_mem_properties *)args->properties, null_terminated_array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->properties = NULL;
    }
    vcl_decode_cl_mem_flags(dec, &args->flags);
    if (vcl_decode_simple_pointer(dec)) {
        args->image_format = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->image_format));
        if (!args->image_format) return;
        vcl_decode_cl_image_format_temp(dec, (cl_image_format *)args->image_format);
    } else {
        args->image_format = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->image_desc = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->image_desc));
        if (!args->image_desc) return;
        vcl_decode_cl_image_desc_MESA_temp(dec, (cl_image_desc_MESA *)args->image_desc);
    } else {
        args->image_desc = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    vcl_decode_size_t(dec, &args->size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->size);
        args->host_ptr = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->host_ptr) return;
        vcl_decode_blob_array(dec, (void *)args->host_ptr, array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->host_ptr = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->image = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->image));
        if (!args->image) return;
        vcl_decode_cl_mem_temp(dec, args->image);
    } else {
        args->image = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_3_0

#ifdef CL_API_SUFFIX__VERSION_3_0
static inline void vcl_replace_clCreateImageWithPropertiesMESA_args_handle(struct vcl_command_clCreateImageWithPropertiesMESA *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->properties */
    /* skip args->flags */
    if (args->image_format)
        vcl_replace_cl_image_format_handle((cl_image_format *)args->image_format);
    if (args->image_desc)
        vcl_replace_cl_image_desc_MESA_handle((cl_image_desc_MESA *)args->image_desc);
    /* skip args->size */
    /* skip args->host_ptr */
    /* skip args->image */
}
#endif // CL_API_SUFFIX__VERSION_3_0

#ifdef CL_API_SUFFIX__VERSION_3_0
static inline void vcl_encode_clCreateImageWithPropertiesMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateImageWithPropertiesMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateImageWithPropertiesMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    /* skip args->properties */
    /* skip args->flags */
    /* skip args->image_format */
    /* skip args->image_desc */
    /* skip args->size */
    /* skip args->host_ptr */
    if (vcl_encode_simple_pointer(enc, args->image))
        vcl_encode_cl_mem(enc, args->image);
}
#endif // CL_API_SUFFIX__VERSION_3_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clEnqueueReadImageMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueReadImageMESA *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_mem_lookup(dec, &args->image);
    vcl_decode_cl_bool(dec, &args->blocking_read);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, 3);
        args->origin = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->origin), array_size);
        if (!args->origin) return;
        vcl_decode_size_t_array(dec, (size_t *)args->origin, array_size);
    } else {
        vcl_decode_array_size(dec, 3);
        args->origin = NULL;
    }
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, 3);
        args->region = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->region), array_size);
        if (!args->region) return;
        vcl_decode_size_t_array(dec, (size_t *)args->region, array_size);
    } else {
        vcl_decode_array_size(dec, 3);
        args->region = NULL;
    }
    vcl_decode_size_t(dec, &args->row_pitch);
    vcl_decode_size_t(dec, &args->slice_pitch);
    vcl_decode_size_t(dec, &args->size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->size);
        args->ptr = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->ptr) return;
    } else {
        vcl_decode_array_size(dec, args->size);
        args->ptr = NULL;
    }
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clEnqueueReadImageMESA_args_handle(struct vcl_command_clEnqueueReadImageMESA *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    vcl_replace_cl_mem_handle(&args->image);
    /* skip args->blocking_read */
    /* skip args->origin */
    /* skip args->region */
    /* skip args->row_pitch */
    /* skip args->slice_pitch */
    /* skip args->size */
    /* skip args->ptr */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clEnqueueReadImageMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueReadImageMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueReadImageMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->image */
    /* skip args->blocking_read */
    /* skip args->origin */
    /* skip args->region */
    /* skip args->row_pitch */
    /* skip args->slice_pitch */
    /* skip args->size */
    if (args->ptr) {
        vcl_encode_array_size(enc, args->size);
        vcl_encode_blob_array(enc, args->ptr, args->size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clEnqueueWriteImageMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueWriteImageMESA *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_mem_lookup(dec, &args->image);
    vcl_decode_cl_bool(dec, &args->blocking_write);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, 3);
        args->origin = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->origin), array_size);
        if (!args->origin) return;
        vcl_decode_size_t_array(dec, (size_t *)args->origin, array_size);
    } else {
        vcl_decode_array_size(dec, 3);
        args->origin = NULL;
    }
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, 3);
        args->region = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->region), array_size);
        if (!args->region) return;
        vcl_decode_size_t_array(dec, (size_t *)args->region, array_size);
    } else {
        vcl_decode_array_size(dec, 3);
        args->region = NULL;
    }
    vcl_decode_size_t(dec, &args->input_row_pitch);
    vcl_decode_size_t(dec, &args->input_slice_pitch);
    vcl_decode_size_t(dec, &args->size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->size);
        args->ptr = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->ptr) return;
        vcl_decode_blob_array(dec, (void *)args->ptr, array_size);
    } else {
        vcl_decode_array_size(dec, args->size);
        args->ptr = NULL;
    }
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clEnqueueWriteImageMESA_args_handle(struct vcl_command_clEnqueueWriteImageMESA *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    vcl_replace_cl_mem_handle(&args->image);
    /* skip args->blocking_write */
    /* skip args->origin */
    /* skip args->region */
    /* skip args->input_row_pitch */
    /* skip args->input_slice_pitch */
    /* skip args->size */
    /* skip args->ptr */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clEnqueueWriteImageMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueWriteImageMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueWriteImageMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->image */
    /* skip args->blocking_write */
    /* skip args->origin */
    /* skip args->region */
    /* skip args->input_row_pitch */
    /* skip args->input_slice_pitch */
    /* skip args->size */
    /* skip args->ptr */
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_decode_clEnqueueFillImageMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueFillImageMESA *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_mem_lookup(dec, &args->image);
    vcl_decode_size_t(dec, &args->size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->size);
        args->fill_color = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->fill_color) return;
        vcl_decode_blob_array(dec, (void *)args->fill_color, array_size);
    } else {
        vcl_decode_array_size(dec, args->size);
        args->fill_color = NULL;
    }
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, 3);
        args->origin = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->origin), array_size);
        if (!args->origin) return;
        vcl_decode_size_t_array(dec, (size_t *)args->origin, array_size);
    } else {
        vcl_decode_array_size(dec, 3);
        args->origin = NULL;
    }
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, 3);
        args->region = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->region), array_size);
        if (!args->region) return;
        vcl_decode_size_t_array(dec, (size_t *)args->region, array_size);
    } else {
        vcl_decode_array_size(dec, 3);
        args->region = NULL;
    }
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_replace_clEnqueueFillImageMESA_args_handle(struct vcl_command_clEnqueueFillImageMESA *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    vcl_replace_cl_mem_handle(&args->image);
    /* skip args->size */
    /* skip args->fill_color */
    /* skip args->origin */
    /* skip args->region */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_encode_clEnqueueFillImageMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueFillImageMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueFillImageMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->image */
    /* skip args->size */
    /* skip args->fill_color */
    /* skip args->origin */
    /* skip args->region */
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clEnqueueMapBufferMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueMapBufferMESA *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_mem_lookup(dec, &args->buffer);
    vcl_decode_cl_bool(dec, &args->blocking_map);
    vcl_decode_cl_map_flags(dec, &args->map_flags);
    vcl_decode_size_t(dec, &args->offset);
    vcl_decode_size_t(dec, &args->size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->size);
        args->ptr = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->ptr) return;
    } else {
        vcl_decode_array_size(dec, args->size);
        args->ptr = NULL;
    }
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clEnqueueMapBufferMESA_args_handle(struct vcl_command_clEnqueueMapBufferMESA *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    vcl_replace_cl_mem_handle(&args->buffer);
    /* skip args->blocking_map */
    /* skip args->map_flags */
    /* skip args->offset */
    /* skip args->size */
    /* skip args->ptr */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clEnqueueMapBufferMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueMapBufferMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueMapBufferMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->buffer */
    /* skip args->blocking_map */
    /* skip args->map_flags */
    /* skip args->offset */
    /* skip args->size */
    if (args->ptr) {
        vcl_encode_array_size(enc, args->size);
        vcl_encode_blob_array(enc, args->ptr, args->size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clEnqueueMapImageMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueMapImageMESA *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_mem_lookup(dec, &args->image);
    vcl_decode_cl_bool(dec, &args->blocking_map);
    vcl_decode_cl_map_flags(dec, &args->map_flags);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, 3);
        args->origin = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->origin), array_size);
        if (!args->origin) return;
        vcl_decode_size_t_array(dec, (size_t *)args->origin, array_size);
    } else {
        vcl_decode_array_size(dec, 3);
        args->origin = NULL;
    }
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, 3);
        args->region = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->region), array_size);
        if (!args->region) return;
        vcl_decode_size_t_array(dec, (size_t *)args->region, array_size);
    } else {
        vcl_decode_array_size(dec, 3);
        args->region = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->image_row_pitch = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->image_row_pitch));
        if (!args->image_row_pitch) return;
    } else {
        args->image_row_pitch = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->image_slice_pitch = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->image_slice_pitch));
        if (!args->image_slice_pitch) return;
    } else {
        args->image_slice_pitch = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    vcl_decode_size_t(dec, &args->size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->size);
        args->ptr = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->ptr) return;
    } else {
        vcl_decode_array_size(dec, args->size);
        args->ptr = NULL;
    }
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clEnqueueMapImageMESA_args_handle(struct vcl_command_clEnqueueMapImageMESA *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    vcl_replace_cl_mem_handle(&args->image);
    /* skip args->blocking_map */
    /* skip args->map_flags */
    /* skip args->origin */
    /* skip args->region */
    /* skip args->image_row_pitch */
    /* skip args->image_slice_pitch */
    /* skip args->size */
    /* skip args->ptr */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clEnqueueMapImageMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueMapImageMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueMapImageMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->image */
    /* skip args->blocking_map */
    /* skip args->map_flags */
    /* skip args->origin */
    /* skip args->region */
    if (vcl_encode_simple_pointer(enc, args->image_row_pitch))
        vcl_encode_size_t(enc, args->image_row_pitch);
    if (vcl_encode_simple_pointer(enc, args->image_slice_pitch))
        vcl_encode_size_t(enc, args->image_slice_pitch);
    /* skip args->size */
    if (args->ptr) {
        vcl_encode_array_size(enc, args->size);
        vcl_encode_blob_array(enc, args->ptr, args->size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clEnqueueUnmapMemObjectMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueUnmapMemObjectMESA *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_mem_lookup(dec, &args->memobj);
    vcl_decode_size_t(dec, &args->size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->size);
        args->mapped_ptr = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->mapped_ptr) return;
        vcl_decode_blob_array(dec, (void *)args->mapped_ptr, array_size);
    } else {
        vcl_decode_array_size(dec, args->size);
        args->mapped_ptr = NULL;
    }
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clEnqueueUnmapMemObjectMESA_args_handle(struct vcl_command_clEnqueueUnmapMemObjectMESA *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    vcl_replace_cl_mem_handle(&args->memobj);
    /* skip args->size */
    /* skip args->mapped_ptr */
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clEnqueueUnmapMemObjectMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueUnmapMemObjectMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueUnmapMemObjectMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->memobj */
    /* skip args->size */
    /* skip args->mapped_ptr */
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0


static inline void vcl_dispatch_clReleaseMemObject(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clReleaseMemObject args;

    if (!ctx->dispatch_clReleaseMemObject) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clReleaseMemObject_args_temp(ctx->decoder, &args);
    if (!args.memobj) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clReleaseMemObject(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clReleaseMemObject returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clReleaseMemObject_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clReleaseMemObject");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clGetSupportedImageFormats(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clGetSupportedImageFormats args;

    if (!ctx->dispatch_clGetSupportedImageFormats) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetSupportedImageFormats_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetSupportedImageFormats(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetSupportedImageFormats returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetSupportedImageFormats_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clGetSupportedImageFormats");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clGetMemObjectInfo(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clGetMemObjectInfo args;

    if (!ctx->dispatch_clGetMemObjectInfo) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetMemObjectInfo_args_temp(ctx->decoder, &args);
    if (!args.memobj) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetMemObjectInfo(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetMemObjectInfo returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetMemObjectInfo_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clGetMemObjectInfo");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clGetImageInfo(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clGetImageInfo args;

    if (!ctx->dispatch_clGetImageInfo) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetImageInfo_args_temp(ctx->decoder, &args);
    if (!args.image) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetImageInfo(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetImageInfo returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetImageInfo_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clGetImageInfo");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clReleaseSampler(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clReleaseSampler args;

    if (!ctx->dispatch_clReleaseSampler) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clReleaseSampler_args_temp(ctx->decoder, &args);
    if (!args.sampler) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clReleaseSampler(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clReleaseSampler returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clReleaseSampler_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clReleaseSampler");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clGetSamplerInfo(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clGetSamplerInfo args;

    if (!ctx->dispatch_clGetSamplerInfo) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetSamplerInfo_args_temp(ctx->decoder, &args);
    if (!args.sampler) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetSamplerInfo(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetSamplerInfo returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetSamplerInfo_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clGetSamplerInfo");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clEnqueueReadBuffer(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clEnqueueReadBuffer args;

    if (!ctx->dispatch_clEnqueueReadBuffer) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueReadBuffer_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueReadBuffer(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueReadBuffer returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueReadBuffer_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clEnqueueReadBuffer");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clEnqueueWriteBuffer(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clEnqueueWriteBuffer args;

    if (!ctx->dispatch_clEnqueueWriteBuffer) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueWriteBuffer_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueWriteBuffer(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueWriteBuffer returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueWriteBuffer_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clEnqueueWriteBuffer");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clEnqueueFillBuffer(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2
    struct vcl_command_clEnqueueFillBuffer args;

    if (!ctx->dispatch_clEnqueueFillBuffer) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueFillBuffer_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueFillBuffer(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueFillBuffer returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueFillBuffer_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2 not available for clEnqueueFillBuffer");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2
}


static inline void vcl_dispatch_clEnqueueCopyBuffer(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clEnqueueCopyBuffer args;

    if (!ctx->dispatch_clEnqueueCopyBuffer) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueCopyBuffer_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueCopyBuffer(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueCopyBuffer returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueCopyBuffer_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clEnqueueCopyBuffer");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clEnqueueCopyBufferRect(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_1
    struct vcl_command_clEnqueueCopyBufferRect args;

    if (!ctx->dispatch_clEnqueueCopyBufferRect) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueCopyBufferRect_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueCopyBufferRect(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueCopyBufferRect returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueCopyBufferRect_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_1 not available for clEnqueueCopyBufferRect");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_1
}


static inline void vcl_dispatch_clEnqueueCopyImage(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clEnqueueCopyImage args;

    if (!ctx->dispatch_clEnqueueCopyImage) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueCopyImage_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueCopyImage(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueCopyImage returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueCopyImage_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clEnqueueCopyImage");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clEnqueueCopyImageToBuffer(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clEnqueueCopyImageToBuffer args;

    if (!ctx->dispatch_clEnqueueCopyImageToBuffer) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueCopyImageToBuffer_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueCopyImageToBuffer(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueCopyImageToBuffer returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueCopyImageToBuffer_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clEnqueueCopyImageToBuffer");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clEnqueueCopyBufferToImage(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clEnqueueCopyBufferToImage args;

    if (!ctx->dispatch_clEnqueueCopyBufferToImage) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueCopyBufferToImage_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueCopyBufferToImage(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueCopyBufferToImage returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueCopyBufferToImage_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clEnqueueCopyBufferToImage");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clEnqueueMigrateMemObjects(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2
    struct vcl_command_clEnqueueMigrateMemObjects args;

    if (!ctx->dispatch_clEnqueueMigrateMemObjects) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueMigrateMemObjects_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueMigrateMemObjects(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueMigrateMemObjects returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueMigrateMemObjects_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2 not available for clEnqueueMigrateMemObjects");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2
}


static inline void vcl_dispatch_clCreateBufferMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clCreateBufferMESA args;

    if (!ctx->dispatch_clCreateBufferMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateBufferMESA_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateBufferMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateBufferMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateBufferMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clCreateBufferMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clCreateBufferWithPropertiesMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_3_0
    struct vcl_command_clCreateBufferWithPropertiesMESA args;

    if (!ctx->dispatch_clCreateBufferWithPropertiesMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateBufferWithPropertiesMESA_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateBufferWithPropertiesMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateBufferWithPropertiesMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateBufferWithPropertiesMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_3_0 not available for clCreateBufferWithPropertiesMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_3_0
}


static inline void vcl_dispatch_clCreateImage2DMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
    struct vcl_command_clCreateImage2DMESA args;

    if (!ctx->dispatch_clCreateImage2DMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateImage2DMESA_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateImage2DMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateImage2DMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateImage2DMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_1_DEPRECATED not available for clCreateImage2DMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED
}


static inline void vcl_dispatch_clCreateImage3DMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
    struct vcl_command_clCreateImage3DMESA args;

    if (!ctx->dispatch_clCreateImage3DMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateImage3DMESA_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateImage3DMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateImage3DMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateImage3DMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_1_DEPRECATED not available for clCreateImage3DMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED
}


static inline void vcl_dispatch_clCreateSamplerMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2_DEPRECATED
    struct vcl_command_clCreateSamplerMESA args;

    if (!ctx->dispatch_clCreateSamplerMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateSamplerMESA_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateSamplerMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateSamplerMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateSamplerMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2_DEPRECATED not available for clCreateSamplerMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2_DEPRECATED
}


static inline void vcl_dispatch_clCreateSamplerWithPropertiesMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_2_0
    struct vcl_command_clCreateSamplerWithPropertiesMESA args;

    if (!ctx->dispatch_clCreateSamplerWithPropertiesMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateSamplerWithPropertiesMESA_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateSamplerWithPropertiesMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateSamplerWithPropertiesMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateSamplerWithPropertiesMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_2_0 not available for clCreateSamplerWithPropertiesMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_2_0
}


static inline void vcl_dispatch_clCreateSubBufferMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_1
    struct vcl_command_clCreateSubBufferMESA args;

    if (!ctx->dispatch_clCreateSubBufferMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateSubBufferMESA_args_temp(ctx->decoder, &args);
    if (!args.buffer) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateSubBufferMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateSubBufferMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateSubBufferMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_1 not available for clCreateSubBufferMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_1
}


static inline void vcl_dispatch_clCreateImageMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2
    struct vcl_command_clCreateImageMESA args;

    if (!ctx->dispatch_clCreateImageMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateImageMESA_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateImageMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateImageMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateImageMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2 not available for clCreateImageMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2
}


static inline void vcl_dispatch_clCreateImageWithPropertiesMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_3_0
    struct vcl_command_clCreateImageWithPropertiesMESA args;

    if (!ctx->dispatch_clCreateImageWithPropertiesMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateImageWithPropertiesMESA_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateImageWithPropertiesMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateImageWithPropertiesMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateImageWithPropertiesMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_3_0 not available for clCreateImageWithPropertiesMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_3_0
}


static inline void vcl_dispatch_clEnqueueReadImageMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clEnqueueReadImageMESA args;

    if (!ctx->dispatch_clEnqueueReadImageMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueReadImageMESA_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueReadImageMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueReadImageMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueReadImageMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clEnqueueReadImageMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clEnqueueWriteImageMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clEnqueueWriteImageMESA args;

    if (!ctx->dispatch_clEnqueueWriteImageMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueWriteImageMESA_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueWriteImageMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueWriteImageMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueWriteImageMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clEnqueueWriteImageMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clEnqueueFillImageMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2
    struct vcl_command_clEnqueueFillImageMESA args;

    if (!ctx->dispatch_clEnqueueFillImageMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueFillImageMESA_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueFillImageMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueFillImageMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueFillImageMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2 not available for clEnqueueFillImageMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2
}


static inline void vcl_dispatch_clEnqueueMapBufferMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clEnqueueMapBufferMESA args;

    if (!ctx->dispatch_clEnqueueMapBufferMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueMapBufferMESA_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueMapBufferMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueMapBufferMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueMapBufferMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clEnqueueMapBufferMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clEnqueueMapImageMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clEnqueueMapImageMESA args;

    if (!ctx->dispatch_clEnqueueMapImageMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueMapImageMESA_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueMapImageMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueMapImageMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueMapImageMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clEnqueueMapImageMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clEnqueueUnmapMemObjectMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clEnqueueUnmapMemObjectMESA args;

    if (!ctx->dispatch_clEnqueueUnmapMemObjectMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueUnmapMemObjectMESA_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueUnmapMemObjectMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueUnmapMemObjectMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueUnmapMemObjectMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clEnqueueUnmapMemObjectMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}

#pragma GCC diagnostic pop

#endif /* VCL_PROTOCOL_RENDERER_MEMORY_H */
