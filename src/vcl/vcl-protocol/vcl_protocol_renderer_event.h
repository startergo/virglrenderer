/* This file is generated by vcl-protocol.  See vcl_protocol_renderer.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#ifndef VCL_PROTOCOL_RENDERER_EVENT_H
#define VCL_PROTOCOL_RENDERER_EVENT_H

#include "vcl_protocol_renderer_structs.h"

#pragma GCC diagnostic push
#if !defined(__clang__) && defined(__GNUC__) && __GNUC__ >= 12
#pragma GCC diagnostic ignored "-Wdangling-pointer"
#endif
#pragma GCC diagnostic ignored "-Wpointer-arith"
#pragma GCC diagnostic ignored "-Wunused-parameter"

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clWaitForEvents_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clWaitForEvents *args)
{
    vcl_decode_cl_uint(dec, &args->num_events);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events);
        args->event_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_list), iter_count);
        if (!args->event_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_list = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clWaitForEvents_args_handle(struct vcl_command_clWaitForEvents *args)
{
    /* skip args->num_events */
    if (args->event_list) {
       for (cl_uint i = 0; i < args->num_events; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_list)[i]);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clWaitForEvents_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clWaitForEvents *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clWaitForEvents_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->num_events */
    /* skip args->event_list */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clGetEventInfo_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetEventInfo *args)
{
    vcl_decode_cl_event_lookup(dec, &args->event);
    vcl_decode_cl_event_info(dec, &args->param_name);
    vcl_decode_size_t(dec, &args->param_value_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->param_value_size);
        args->param_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->param_value) return;
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->param_value = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->param_value_size_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->param_value_size_ret));
        if (!args->param_value_size_ret) return;
    } else {
        args->param_value_size_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clGetEventInfo_args_handle(struct vcl_command_clGetEventInfo *args)
{
    vcl_replace_cl_event_handle(&args->event);
    /* skip args->param_name */
    /* skip args->param_value_size */
    /* skip args->param_value */
    /* skip args->param_value_size_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clGetEventInfo_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetEventInfo *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetEventInfo_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->event */
    /* skip args->param_name */
    /* skip args->param_value_size */
    if (args->param_value) {
        vcl_encode_array_size(enc, args->param_value_size);
        vcl_encode_blob_array(enc, args->param_value, args->param_value_size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->param_value_size_ret))
        vcl_encode_size_t(enc, args->param_value_size_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clReleaseEvent_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clReleaseEvent *args)
{
    vcl_decode_cl_event_lookup(dec, &args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clReleaseEvent_args_handle(struct vcl_command_clReleaseEvent *args)
{
    vcl_replace_cl_event_handle(&args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clReleaseEvent_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clReleaseEvent *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clReleaseEvent_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_decode_clSetUserEventStatus_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clSetUserEventStatus *args)
{
    vcl_decode_cl_event_lookup(dec, &args->event);
    vcl_decode_cl_int(dec, &args->execution_status);
}
#endif // CL_API_SUFFIX__VERSION_1_1

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_replace_clSetUserEventStatus_args_handle(struct vcl_command_clSetUserEventStatus *args)
{
    vcl_replace_cl_event_handle(&args->event);
    /* skip args->execution_status */
}
#endif // CL_API_SUFFIX__VERSION_1_1

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_encode_clSetUserEventStatus_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clSetUserEventStatus *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clSetUserEventStatus_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->event */
    /* skip args->execution_status */
}
#endif // CL_API_SUFFIX__VERSION_1_1

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_decode_clSetEventCallback_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clSetEventCallback *args)
{
    vcl_decode_cl_event_lookup(dec, &args->event);
    vcl_decode_cl_int(dec, &args->command_exec_callback_type);
    if (vcl_decode_simple_pointer(dec)) {
        vcl_cs_decoder_set_fatal(dec);
    } else {
        args->user_data = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_1

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_replace_clSetEventCallback_args_handle(struct vcl_command_clSetEventCallback *args)
{
    vcl_replace_cl_event_handle(&args->event);
    /* skip args->command_exec_callback_type */
    /* skip args->user_data */
}
#endif // CL_API_SUFFIX__VERSION_1_1

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_encode_clSetEventCallback_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clSetEventCallback *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clSetEventCallback_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->event */
    /* skip args->command_exec_callback_type */
    if (vcl_encode_simple_pointer(enc, args->user_data))
        assert(false);
}
#endif // CL_API_SUFFIX__VERSION_1_1

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clGetEventProfilingInfo_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetEventProfilingInfo *args)
{
    vcl_decode_cl_event_lookup(dec, &args->event);
    vcl_decode_cl_profiling_info(dec, &args->param_name);
    vcl_decode_size_t(dec, &args->param_value_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->param_value_size);
        args->param_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->param_value) return;
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->param_value = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->param_value_size_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->param_value_size_ret));
        if (!args->param_value_size_ret) return;
    } else {
        args->param_value_size_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clGetEventProfilingInfo_args_handle(struct vcl_command_clGetEventProfilingInfo *args)
{
    vcl_replace_cl_event_handle(&args->event);
    /* skip args->param_name */
    /* skip args->param_value_size */
    /* skip args->param_value */
    /* skip args->param_value_size_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clGetEventProfilingInfo_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetEventProfilingInfo *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetEventProfilingInfo_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->event */
    /* skip args->param_name */
    /* skip args->param_value_size */
    if (args->param_value) {
        vcl_encode_array_size(enc, args->param_value_size);
        vcl_encode_blob_array(enc, args->param_value, args->param_value_size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->param_value_size_ret))
        vcl_encode_size_t(enc, args->param_value_size_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_decode_clEnqueueMarkerWithWaitList_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueMarkerWithWaitList *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_replace_clEnqueueMarkerWithWaitList_args_handle(struct vcl_command_clEnqueueMarkerWithWaitList *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_encode_clEnqueueMarkerWithWaitList_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueMarkerWithWaitList *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueMarkerWithWaitList_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_decode_clEnqueueBarrierWithWaitList_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueBarrierWithWaitList *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_uint(dec, &args->num_events_in_wait_list);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events_in_wait_list);
        args->event_wait_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_wait_list), iter_count);
        if (!args->event_wait_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_wait_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->event_wait_list = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_replace_clEnqueueBarrierWithWaitList_args_handle(struct vcl_command_clEnqueueBarrierWithWaitList *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    /* skip args->num_events_in_wait_list */
    if (args->event_wait_list) {
       for (cl_uint i = 0; i < args->num_events_in_wait_list; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_wait_list)[i]);
    }
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_encode_clEnqueueBarrierWithWaitList_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueBarrierWithWaitList *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueBarrierWithWaitList_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->num_events_in_wait_list */
    /* skip args->event_wait_list */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_decode_clEnqueueWaitForEvents_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clEnqueueWaitForEvents *args)
{
    vcl_decode_cl_command_queue_lookup(dec, &args->command_queue);
    vcl_decode_cl_uint(dec, &args->num_events);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_events);
        args->event_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->event_list), iter_count);
        if (!args->event_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_event_lookup(dec, &((cl_event *)args->event_list)[i]);
    } else {
        vcl_decode_array_size(dec, args->num_events);
        args->event_list = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_replace_clEnqueueWaitForEvents_args_handle(struct vcl_command_clEnqueueWaitForEvents *args)
{
    vcl_replace_cl_command_queue_handle(&args->command_queue);
    /* skip args->num_events */
    if (args->event_list) {
       for (cl_uint i = 0; i < args->num_events; i++)
            vcl_replace_cl_event_handle(&((cl_event *)args->event_list)[i]);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
static inline void vcl_encode_clEnqueueWaitForEvents_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clEnqueueWaitForEvents *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clEnqueueWaitForEvents_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->command_queue */
    /* skip args->num_events */
    /* skip args->event_list */
}
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_decode_clCreateUserEventMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateUserEventMESA *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    if (vcl_decode_simple_pointer(dec)) {
        args->event = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->event));
        if (!args->event) return;
        vcl_decode_cl_event_temp(dec, args->event);
    } else {
        args->event = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_1

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_replace_clCreateUserEventMESA_args_handle(struct vcl_command_clCreateUserEventMESA *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->event */
}
#endif // CL_API_SUFFIX__VERSION_1_1

#ifdef CL_API_SUFFIX__VERSION_1_1
static inline void vcl_encode_clCreateUserEventMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateUserEventMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateUserEventMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    if (vcl_encode_simple_pointer(enc, args->event))
        vcl_encode_cl_event(enc, args->event);
}
#endif // CL_API_SUFFIX__VERSION_1_1


static inline void vcl_dispatch_clWaitForEvents(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clWaitForEvents args;

    if (!ctx->dispatch_clWaitForEvents) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clWaitForEvents_args_temp(ctx->decoder, &args);

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clWaitForEvents(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clWaitForEvents returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clWaitForEvents_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clWaitForEvents");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clGetEventInfo(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clGetEventInfo args;

    if (!ctx->dispatch_clGetEventInfo) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetEventInfo_args_temp(ctx->decoder, &args);
    if (!args.event) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetEventInfo(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetEventInfo returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetEventInfo_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clGetEventInfo");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clReleaseEvent(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clReleaseEvent args;

    if (!ctx->dispatch_clReleaseEvent) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clReleaseEvent_args_temp(ctx->decoder, &args);
    if (!args.event) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clReleaseEvent(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clReleaseEvent returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clReleaseEvent_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clReleaseEvent");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clSetUserEventStatus(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_1
    struct vcl_command_clSetUserEventStatus args;

    if (!ctx->dispatch_clSetUserEventStatus) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clSetUserEventStatus_args_temp(ctx->decoder, &args);
    if (!args.event) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clSetUserEventStatus(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clSetUserEventStatus returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clSetUserEventStatus_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_1 not available for clSetUserEventStatus");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_1
}


static inline void vcl_dispatch_clSetEventCallback(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_1
    struct vcl_command_clSetEventCallback args;

    if (!ctx->dispatch_clSetEventCallback) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clSetEventCallback_args_temp(ctx->decoder, &args);
    if (!args.event) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clSetEventCallback(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clSetEventCallback returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clSetEventCallback_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_1 not available for clSetEventCallback");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_1
}


static inline void vcl_dispatch_clGetEventProfilingInfo(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clGetEventProfilingInfo args;

    if (!ctx->dispatch_clGetEventProfilingInfo) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetEventProfilingInfo_args_temp(ctx->decoder, &args);
    if (!args.event) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetEventProfilingInfo(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetEventProfilingInfo returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetEventProfilingInfo_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clGetEventProfilingInfo");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clEnqueueMarkerWithWaitList(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2
    struct vcl_command_clEnqueueMarkerWithWaitList args;

    if (!ctx->dispatch_clEnqueueMarkerWithWaitList) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueMarkerWithWaitList_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueMarkerWithWaitList(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueMarkerWithWaitList returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueMarkerWithWaitList_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2 not available for clEnqueueMarkerWithWaitList");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2
}


static inline void vcl_dispatch_clEnqueueBarrierWithWaitList(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2
    struct vcl_command_clEnqueueBarrierWithWaitList args;

    if (!ctx->dispatch_clEnqueueBarrierWithWaitList) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueBarrierWithWaitList_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueBarrierWithWaitList(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueBarrierWithWaitList returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueBarrierWithWaitList_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2 not available for clEnqueueBarrierWithWaitList");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2
}


static inline void vcl_dispatch_clEnqueueWaitForEvents(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_1_DEPRECATED
    struct vcl_command_clEnqueueWaitForEvents args;

    if (!ctx->dispatch_clEnqueueWaitForEvents) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clEnqueueWaitForEvents_args_temp(ctx->decoder, &args);
    if (!args.command_queue) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clEnqueueWaitForEvents(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clEnqueueWaitForEvents returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clEnqueueWaitForEvents_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_1_DEPRECATED not available for clEnqueueWaitForEvents");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_1_DEPRECATED
}


static inline void vcl_dispatch_clCreateUserEventMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_1
    struct vcl_command_clCreateUserEventMESA args;

    if (!ctx->dispatch_clCreateUserEventMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateUserEventMESA_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateUserEventMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateUserEventMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateUserEventMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_1 not available for clCreateUserEventMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_1
}

#pragma GCC diagnostic pop

#endif /* VCL_PROTOCOL_RENDERER_EVENT_H */
