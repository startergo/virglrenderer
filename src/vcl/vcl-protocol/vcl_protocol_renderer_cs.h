/* This file is generated by vcl-protocol.  See vcl_protocol_renderer.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#ifndef VCL_PROTOCOL_RENDERER_CS_H
#define VCL_PROTOCOL_RENDERER_CS_H

#include <assert.h>

/*
 * These types/functions are expected
 *
 *   struct vcl_cs_encoder
 *   vcl_cs_encoder_write
 *
 *   struct vcl_cs_decoder
 *   vcl_cs_decoder_set_fatal
 *   vcl_cs_decoder_get_fatal
 *   vcl_cs_decoder_lookup_object
 *   vcl_cs_decoder_reset_temp_pool
 *   vcl_cs_decoder_alloc_temp
 *   vcl_cs_decoder_read
 *   vcl_cs_decoder_peek
 *
 *   vcl_object_id
 *   vcl_cs_handle_load_id
 *   vcl_cs_handle_store_id
 *   vcl_cs_get_object_handle
 */
#include "vcomp_cs.h"

struct vcl_cs_encoder;
struct vcl_cs_decoder;

typedef vcomp_object_id vcl_object_id;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

static inline void
vcl_cs_encoder_write(struct vcl_cs_encoder *enc, size_t size, const void *val, size_t val_size)
{
   struct vcomp_cs_encoder *e = (struct vcomp_cs_encoder *)enc;
   vcomp_cs_encoder_write(e, size, val, val_size);
}

static inline void
vcl_cs_decoder_set_fatal(const struct vcl_cs_decoder *dec)
{
   const struct vcomp_cs_decoder *d = (struct vcomp_cs_decoder *)dec;
   vcomp_cs_decoder_set_fatal(d);
}

static inline bool
vcl_cs_decoder_get_fatal(const struct vcl_cs_decoder *dec)
{
   const struct vcomp_cs_decoder *d = (struct vcomp_cs_decoder *)dec;
   return vcomp_cs_decoder_get_fatal(d);
}

static inline void *
vcl_cs_decoder_lookup_object(const struct vcl_cs_decoder *dec, vcl_object_id id)
{
   const struct vcomp_cs_decoder *d = (const struct vcomp_cs_decoder *)dec;
   return vcomp_cs_decoder_lookup_object(d, id);
}

static inline void
vcl_cs_decoder_reset_temp_pool(struct vcl_cs_decoder *dec)
{
   struct vcomp_cs_decoder *d = (struct vcomp_cs_decoder *)dec;
   vcomp_cs_decoder_reset_temp_pool(d);
}

static inline void *
vcl_cs_decoder_alloc_temp(struct vcl_cs_decoder *dec, size_t size)
{
   struct vcomp_cs_decoder *d = (struct vcomp_cs_decoder *)dec;
   return vcomp_cs_decoder_alloc_temp(d, size);
}

static inline void *
vcl_cs_decoder_alloc_temp_array(struct vcl_cs_decoder *dec, size_t size, size_t count)
{
   struct vcomp_cs_decoder *d = (struct vcomp_cs_decoder *)dec;
   return vcomp_cs_decoder_alloc_temp_array(d, size, count);
}

static inline void
vcl_cs_decoder_read(struct vcl_cs_decoder *dec, size_t size, void *val, size_t val_size)
{
   struct vcomp_cs_decoder *d = (struct vcomp_cs_decoder *)dec;
   vcomp_cs_decoder_read(d, size, val, val_size);
}

static inline void
vcl_cs_decoder_peek(const struct vcl_cs_decoder *dec, size_t size, void *val, size_t val_size)
{
   const struct vcomp_cs_decoder *d = (const struct vcomp_cs_decoder *)dec;
   vcomp_cs_decoder_peek(d, size, val, val_size);
}

static inline vcl_object_id
vcl_cs_handle_load_id(const void **handle)
{
   return vcomp_cs_handle_load_id(handle);
}

static inline void
vcl_cs_handle_store_id(void **handle, vcl_object_id id)
{
    vcomp_cs_handle_store_id(handle, id);
}

static inline uint64_t
vcl_cs_get_object_handle(const void **handle)
{
   const struct vcomp_object *obj = *(const struct vcomp_object **)handle;
   return obj ? obj->handle.u64 : 0;
}

static inline void
vcl_encode(struct vcl_cs_encoder *enc, size_t size, const void *data, size_t data_size)
{
   assert(size % 4 == 0);
   /* no vcl_cs_encoder_reserve; vcl_cs_encoder_write must do size check */
   /* TODO check if the generated code is optimal */
   vcl_cs_encoder_write(enc, size, data, data_size);
}

static inline void
vcl_decode(struct vcl_cs_decoder *dec, size_t size, void *data, size_t data_size)
{
   assert(size % 4 == 0);
   vcl_cs_decoder_read(dec, size, data, data_size);
}

#pragma GCC diagnostic pop

#endif /* VCL_PROTOCOL_RENDERER_CS_H */
