/* This file is generated by vcl-protocol.  See vcl_protocol_renderer.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#ifndef VCL_PROTOCOL_RENDERER_CONTEXT_H
#define VCL_PROTOCOL_RENDERER_CONTEXT_H

#include "vcl_protocol_renderer_structs.h"

#pragma GCC diagnostic push
#if !defined(__clang__) && defined(__GNUC__) && __GNUC__ >= 12
#pragma GCC diagnostic ignored "-Wdangling-pointer"
#endif
#pragma GCC diagnostic ignored "-Wpointer-arith"
#pragma GCC diagnostic ignored "-Wunused-parameter"

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clRetainContext_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clRetainContext *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clRetainContext_args_handle(struct vcl_command_clRetainContext *args)
{
    vcl_replace_cl_context_handle(&args->context);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clRetainContext_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clRetainContext *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clRetainContext_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clReleaseContext_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clReleaseContext *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clReleaseContext_args_handle(struct vcl_command_clReleaseContext *args)
{
    vcl_replace_cl_context_handle(&args->context);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clReleaseContext_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clReleaseContext *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clReleaseContext_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clGetContextInfo_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetContextInfo *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_context_info(dec, &args->param_name);
    vcl_decode_size_t(dec, &args->param_value_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->param_value_size);
        args->param_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->param_value) return;
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->param_value = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->param_value_size_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->param_value_size_ret));
        if (!args->param_value_size_ret) return;
    } else {
        args->param_value_size_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clGetContextInfo_args_handle(struct vcl_command_clGetContextInfo *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->param_name */
    /* skip args->param_value_size */
    /* skip args->param_value */
    /* skip args->param_value_size_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clGetContextInfo_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetContextInfo *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetContextInfo_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    /* skip args->param_name */
    /* skip args->param_value_size */
    if (args->param_value) {
        vcl_encode_array_size(enc, args->param_value_size);
        vcl_encode_blob_array(enc, args->param_value, args->param_value_size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->param_value_size_ret))
        vcl_encode_size_t(enc, args->param_value_size_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clCreateContextMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateContextMESA *args)
{
    if (vcl_peek_array_size(dec)) {
        const size_t null_terminated_array_size = vcl_decode_array_size_unchecked(dec);
        args->properties = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->properties), null_terminated_array_size);
        if (!args->properties) return;
        vcl_decode_cl_context_properties_array(dec, (cl_context_properties *)args->properties, null_terminated_array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->properties = NULL;
    }
    vcl_decode_cl_uint(dec, &args->num_devices);
    if (vcl_decode_simple_pointer(dec)) {
        args->devices = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->devices));
        if (!args->devices) return;
        vcl_decode_cl_device_id_lookup(dec, (cl_device_id *)args->devices);
    } else {
        args->devices = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
    if (vcl_decode_simple_pointer(dec)) {
        vcl_cs_decoder_set_fatal(dec);
    } else {
        args->user_data = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->context = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->context));
        if (!args->context) return;
        vcl_decode_cl_context_temp(dec, args->context);
    } else {
        args->context = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clCreateContextMESA_args_handle(struct vcl_command_clCreateContextMESA *args)
{
    /* skip args->properties */
    /* skip args->num_devices */
    if (args->devices)
        vcl_replace_cl_device_id_handle((cl_device_id *)args->devices);
    /* skip args->user_data */
    /* skip args->context */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clCreateContextMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateContextMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateContextMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->properties */
    /* skip args->num_devices */
    /* skip args->devices */
    if (vcl_encode_simple_pointer(enc, args->user_data))
        assert(false);
    if (vcl_encode_simple_pointer(enc, args->context))
        vcl_encode_cl_context(enc, args->context);
}
#endif // CL_API_SUFFIX__VERSION_1_0


static inline void vcl_dispatch_clRetainContext(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clRetainContext args;

    if (!ctx->dispatch_clRetainContext) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clRetainContext_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clRetainContext(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clRetainContext returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clRetainContext_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clRetainContext");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clReleaseContext(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clReleaseContext args;

    if (!ctx->dispatch_clReleaseContext) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clReleaseContext_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clReleaseContext(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clReleaseContext returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clReleaseContext_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clReleaseContext");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clGetContextInfo(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clGetContextInfo args;

    if (!ctx->dispatch_clGetContextInfo) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetContextInfo_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetContextInfo(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetContextInfo returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetContextInfo_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clGetContextInfo");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clCreateContextMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clCreateContextMESA args;

    if (!ctx->dispatch_clCreateContextMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateContextMESA_args_temp(ctx->decoder, &args);

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateContextMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateContextMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateContextMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clCreateContextMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}

#pragma GCC diagnostic pop

#endif /* VCL_PROTOCOL_RENDERER_CONTEXT_H */
