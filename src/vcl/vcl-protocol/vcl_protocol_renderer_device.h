/* This file is generated by vcl-protocol.  See vcl_protocol_renderer.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#ifndef VCL_PROTOCOL_RENDERER_DEVICE_H
#define VCL_PROTOCOL_RENDERER_DEVICE_H

#include "vcl_protocol_renderer_structs.h"

#pragma GCC diagnostic push
#if !defined(__clang__) && defined(__GNUC__) && __GNUC__ >= 12
#pragma GCC diagnostic ignored "-Wdangling-pointer"
#endif
#pragma GCC diagnostic ignored "-Wpointer-arith"
#pragma GCC diagnostic ignored "-Wunused-parameter"

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clGetDeviceIDs_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetDeviceIDs *args)
{
    vcl_decode_cl_platform_id_lookup(dec, &args->platform);
    vcl_decode_cl_device_type(dec, &args->device_type);
    vcl_decode_cl_uint(dec, &args->num_entries);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_entries);
        args->devices = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->devices), iter_count);
        if (!args->devices) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_device_id_temp(dec, &args->devices[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->devices = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->num_devices = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->num_devices));
        if (!args->num_devices) return;
    } else {
        args->num_devices = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clGetDeviceIDs_args_handle(struct vcl_command_clGetDeviceIDs *args)
{
    vcl_replace_cl_platform_id_handle(&args->platform);
    /* skip args->device_type */
    /* skip args->num_entries */
    /* skip args->devices */
    /* skip args->num_devices */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clGetDeviceIDs_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetDeviceIDs *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetDeviceIDs_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->platform */
    /* skip args->device_type */
    /* skip args->num_entries */
    if (args->devices) {
        vcl_encode_array_size(enc, args->num_entries);
        for (cl_uint i = 0; i < args->num_entries; i++)
            vcl_encode_cl_device_id(enc, &args->devices[i]);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->num_devices))
        vcl_encode_cl_uint(enc, args->num_devices);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clGetDeviceInfo_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetDeviceInfo *args)
{
    vcl_decode_cl_device_id_lookup(dec, &args->device);
    vcl_decode_cl_device_info(dec, &args->param_name);
    vcl_decode_size_t(dec, &args->param_value_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->param_value_size);
        args->param_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->param_value) return;
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->param_value = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->param_value_size_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->param_value_size_ret));
        if (!args->param_value_size_ret) return;
    } else {
        args->param_value_size_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clGetDeviceInfo_args_handle(struct vcl_command_clGetDeviceInfo *args)
{
    vcl_replace_cl_device_id_handle(&args->device);
    /* skip args->param_name */
    /* skip args->param_value_size */
    /* skip args->param_value */
    /* skip args->param_value_size_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clGetDeviceInfo_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetDeviceInfo *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetDeviceInfo_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->device */
    /* skip args->param_name */
    /* skip args->param_value_size */
    if (args->param_value) {
        vcl_encode_array_size(enc, args->param_value_size);
        vcl_encode_blob_array(enc, args->param_value, args->param_value_size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->param_value_size_ret))
        vcl_encode_size_t(enc, args->param_value_size_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0


static inline void vcl_dispatch_clGetDeviceIDs(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clGetDeviceIDs args;

    if (!ctx->dispatch_clGetDeviceIDs) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetDeviceIDs_args_temp(ctx->decoder, &args);
    if (!args.platform) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetDeviceIDs(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetDeviceIDs returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetDeviceIDs_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clGetDeviceIDs");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clGetDeviceInfo(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clGetDeviceInfo args;

    if (!ctx->dispatch_clGetDeviceInfo) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetDeviceInfo_args_temp(ctx->decoder, &args);
    if (!args.device) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetDeviceInfo(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetDeviceInfo returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetDeviceInfo_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clGetDeviceInfo");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}

#pragma GCC diagnostic pop

#endif /* VCL_PROTOCOL_RENDERER_DEVICE_H */
