/* This file is generated by vcl-protocol.  See vcl_protocol_renderer.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#ifndef VCL_PROTOCOL_RENDERER_PROGRAM_H
#define VCL_PROTOCOL_RENDERER_PROGRAM_H

#include "vcl_protocol_renderer_structs.h"

#pragma GCC diagnostic push
#if !defined(__clang__) && defined(__GNUC__) && __GNUC__ >= 12
#pragma GCC diagnostic ignored "-Wdangling-pointer"
#endif
#pragma GCC diagnostic ignored "-Wpointer-arith"
#pragma GCC diagnostic ignored "-Wunused-parameter"

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clReleaseProgram_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clReleaseProgram *args)
{
    vcl_decode_cl_program_lookup(dec, &args->program);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clReleaseProgram_args_handle(struct vcl_command_clReleaseProgram *args)
{
    vcl_replace_cl_program_handle(&args->program);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clReleaseProgram_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clReleaseProgram *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clReleaseProgram_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->program */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clBuildProgram_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clBuildProgram *args)
{
    vcl_decode_cl_program_lookup(dec, &args->program);
    vcl_decode_cl_uint(dec, &args->num_devices);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_devices);
        args->device_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->device_list), iter_count);
        if (!args->device_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_device_id_lookup(dec, &((cl_device_id *)args->device_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->device_list = NULL;
    }
    if (vcl_peek_array_size(dec)) {
        const size_t null_terminated_array_size = vcl_decode_array_size_unchecked(dec);
        args->options = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->options), null_terminated_array_size);
        if (!args->options) return;
        vcl_decode_char_array(dec, (char *)args->options, null_terminated_array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->options = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        vcl_cs_decoder_set_fatal(dec);
    } else {
        args->user_data = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clBuildProgram_args_handle(struct vcl_command_clBuildProgram *args)
{
    vcl_replace_cl_program_handle(&args->program);
    /* skip args->num_devices */
    if (args->device_list) {
       for (cl_uint i = 0; i < args->num_devices; i++)
            vcl_replace_cl_device_id_handle(&((cl_device_id *)args->device_list)[i]);
    }
    /* skip args->options */
    /* skip args->user_data */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clBuildProgram_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clBuildProgram *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clBuildProgram_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->program */
    /* skip args->num_devices */
    /* skip args->device_list */
    /* skip args->options */
    if (vcl_encode_simple_pointer(enc, args->user_data))
        assert(false);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_decode_clCompileProgram_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCompileProgram *args)
{
    vcl_decode_cl_program_lookup(dec, &args->program);
    vcl_decode_cl_uint(dec, &args->num_devices);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_devices);
        args->device_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->device_list), iter_count);
        if (!args->device_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_device_id_lookup(dec, &((cl_device_id *)args->device_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->device_list = NULL;
    }
    if (vcl_peek_array_size(dec)) {
        const size_t null_terminated_array_size = vcl_decode_array_size_unchecked(dec);
        args->options = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->options), null_terminated_array_size);
        if (!args->options) return;
        vcl_decode_char_array(dec, (char *)args->options, null_terminated_array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->options = NULL;
    }
    vcl_decode_cl_uint(dec, &args->num_input_headers);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_input_headers);
        args->input_headers = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->input_headers), iter_count);
        if (!args->input_headers) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_program_lookup(dec, &((cl_program *)args->input_headers)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->input_headers = NULL;
    }
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_input_headers);
        args->header_include_names = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->header_include_names), iter_count);
        if (!args->header_include_names) return;
        for (cl_uint i = 0; i < iter_count; i++) {
            const size_t null_terminated_array_size = vcl_decode_array_size_unchecked(dec);
            ((char **)args->header_include_names)[i] = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->header_include_names[i]), null_terminated_array_size);
            if (!args->header_include_names[i]) return;
            vcl_decode_char_array(dec, ((char **)args->header_include_names)[i], null_terminated_array_size);
        }
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->header_include_names = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        vcl_cs_decoder_set_fatal(dec);
    } else {
        args->user_data = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_replace_clCompileProgram_args_handle(struct vcl_command_clCompileProgram *args)
{
    vcl_replace_cl_program_handle(&args->program);
    /* skip args->num_devices */
    if (args->device_list) {
       for (cl_uint i = 0; i < args->num_devices; i++)
            vcl_replace_cl_device_id_handle(&((cl_device_id *)args->device_list)[i]);
    }
    /* skip args->options */
    /* skip args->num_input_headers */
    if (args->input_headers) {
       for (cl_uint i = 0; i < args->num_input_headers; i++)
            vcl_replace_cl_program_handle(&((cl_program *)args->input_headers)[i]);
    }
    /* skip args->header_include_names */
    /* skip args->user_data */
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_encode_clCompileProgram_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCompileProgram *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCompileProgram_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->program */
    /* skip args->num_devices */
    /* skip args->device_list */
    /* skip args->options */
    /* skip args->num_input_headers */
    /* skip args->input_headers */
    /* skip args->header_include_names */
    if (vcl_encode_simple_pointer(enc, args->user_data))
        assert(false);
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clGetProgramInfo_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetProgramInfo *args)
{
    vcl_decode_cl_program_lookup(dec, &args->program);
    vcl_decode_cl_program_info(dec, &args->param_name);
    vcl_decode_size_t(dec, &args->param_value_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->param_value_size);
        args->param_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->param_value) return;
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->param_value = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->param_value_size_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->param_value_size_ret));
        if (!args->param_value_size_ret) return;
    } else {
        args->param_value_size_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clGetProgramInfo_args_handle(struct vcl_command_clGetProgramInfo *args)
{
    vcl_replace_cl_program_handle(&args->program);
    /* skip args->param_name */
    /* skip args->param_value_size */
    /* skip args->param_value */
    /* skip args->param_value_size_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clGetProgramInfo_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetProgramInfo *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetProgramInfo_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->program */
    /* skip args->param_name */
    /* skip args->param_value_size */
    if (args->param_value) {
        vcl_encode_array_size(enc, args->param_value_size);
        vcl_encode_blob_array(enc, args->param_value, args->param_value_size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->param_value_size_ret))
        vcl_encode_size_t(enc, args->param_value_size_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clGetProgramBuildInfo_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetProgramBuildInfo *args)
{
    vcl_decode_cl_program_lookup(dec, &args->program);
    vcl_decode_cl_device_id_lookup(dec, &args->device);
    vcl_decode_cl_program_build_info(dec, &args->param_name);
    vcl_decode_size_t(dec, &args->param_value_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->param_value_size);
        args->param_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->param_value) return;
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->param_value = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->param_value_size_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->param_value_size_ret));
        if (!args->param_value_size_ret) return;
    } else {
        args->param_value_size_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clGetProgramBuildInfo_args_handle(struct vcl_command_clGetProgramBuildInfo *args)
{
    vcl_replace_cl_program_handle(&args->program);
    vcl_replace_cl_device_id_handle(&args->device);
    /* skip args->param_name */
    /* skip args->param_value_size */
    /* skip args->param_value */
    /* skip args->param_value_size_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clGetProgramBuildInfo_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetProgramBuildInfo *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetProgramBuildInfo_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->program */
    /* skip args->device */
    /* skip args->param_name */
    /* skip args->param_value_size */
    if (args->param_value) {
        vcl_encode_array_size(enc, args->param_value_size);
        vcl_encode_blob_array(enc, args->param_value, args->param_value_size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->param_value_size_ret))
        vcl_encode_size_t(enc, args->param_value_size_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clCreateProgramWithSourceMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateProgramWithSourceMESA *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_uint(dec, &args->count);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->count);
        args->strings = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->strings), iter_count);
        if (!args->strings) return;
        for (cl_uint i = 0; i < iter_count; i++) {
            const size_t null_terminated_array_size = vcl_decode_array_size_unchecked(dec);
            ((char **)args->strings)[i] = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->strings[i]), null_terminated_array_size);
            if (!args->strings[i]) return;
            vcl_decode_char_array(dec, ((char **)args->strings)[i], null_terminated_array_size);
        }
    } else {
        vcl_decode_array_size(dec, args->count);
        args->strings = NULL;
    }
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->count);
        args->lengths = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->lengths), array_size);
        if (!args->lengths) return;
        vcl_decode_size_t_array(dec, (size_t *)args->lengths, array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->lengths = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->program = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->program));
        if (!args->program) return;
        vcl_decode_cl_program_temp(dec, args->program);
    } else {
        args->program = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clCreateProgramWithSourceMESA_args_handle(struct vcl_command_clCreateProgramWithSourceMESA *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->count */
    /* skip args->strings */
    /* skip args->lengths */
    /* skip args->program */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clCreateProgramWithSourceMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateProgramWithSourceMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateProgramWithSourceMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    /* skip args->count */
    /* skip args->strings */
    /* skip args->lengths */
    if (vcl_encode_simple_pointer(enc, args->program))
        vcl_encode_cl_program(enc, args->program);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clCreateProgramWithBinaryMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateProgramWithBinaryMESA *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_uint(dec, &args->num_devices);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_devices);
        args->device_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->device_list), iter_count);
        if (!args->device_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_device_id_lookup(dec, &((cl_device_id *)args->device_list)[i]);
    } else {
        vcl_decode_array_size(dec, args->num_devices);
        args->device_list = NULL;
    }
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->num_devices);
        args->lengths = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->lengths), array_size);
        if (!args->lengths) return;
        vcl_decode_size_t_array(dec, (size_t *)args->lengths, array_size);
    } else {
        vcl_decode_array_size(dec, args->num_devices);
        args->lengths = NULL;
    }
    vcl_decode_size_t(dec, &args->binaries_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->binaries_size);
        args->binaries = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->binaries), array_size);
        if (!args->binaries) return;
        vcl_decode_uint8_t_array(dec, (uint8_t *)args->binaries, array_size);
    } else {
        vcl_decode_array_size(dec, args->binaries_size);
        args->binaries = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->binary_status = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->binary_status));
        if (!args->binary_status) return;
    } else {
        args->binary_status = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->program = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->program));
        if (!args->program) return;
        vcl_decode_cl_program_temp(dec, args->program);
    } else {
        args->program = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clCreateProgramWithBinaryMESA_args_handle(struct vcl_command_clCreateProgramWithBinaryMESA *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->num_devices */
    if (args->device_list) {
       for (cl_uint i = 0; i < args->num_devices; i++)
            vcl_replace_cl_device_id_handle(&((cl_device_id *)args->device_list)[i]);
    }
    /* skip args->lengths */
    /* skip args->binaries_size */
    /* skip args->binaries */
    /* skip args->binary_status */
    /* skip args->program */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clCreateProgramWithBinaryMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateProgramWithBinaryMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateProgramWithBinaryMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    /* skip args->num_devices */
    /* skip args->device_list */
    /* skip args->lengths */
    /* skip args->binaries_size */
    /* skip args->binaries */
    if (vcl_encode_simple_pointer(enc, args->binary_status))
        vcl_encode_cl_int(enc, args->binary_status);
    if (vcl_encode_simple_pointer(enc, args->program))
        vcl_encode_cl_program(enc, args->program);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_decode_clCreateProgramWithILMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clCreateProgramWithILMESA *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_size_t(dec, &args->length);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->length);
        args->il = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->il) return;
        vcl_decode_blob_array(dec, (void *)args->il, array_size);
    } else {
        vcl_decode_array_size(dec, args->length);
        args->il = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->program = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->program));
        if (!args->program) return;
        vcl_decode_cl_program_temp(dec, args->program);
    } else {
        args->program = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_replace_clCreateProgramWithILMESA_args_handle(struct vcl_command_clCreateProgramWithILMESA *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->length */
    /* skip args->il */
    /* skip args->program */
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_2_1
static inline void vcl_encode_clCreateProgramWithILMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clCreateProgramWithILMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clCreateProgramWithILMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    /* skip args->length */
    /* skip args->il */
    if (vcl_encode_simple_pointer(enc, args->program))
        vcl_encode_cl_program(enc, args->program);
}
#endif // CL_API_SUFFIX__VERSION_2_1

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_decode_clLinkProgramMESA_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clLinkProgramMESA *args)
{
    vcl_decode_cl_context_lookup(dec, &args->context);
    vcl_decode_cl_uint(dec, &args->num_devices);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_devices);
        args->device_list = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->device_list), iter_count);
        if (!args->device_list) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_device_id_lookup(dec, &((cl_device_id *)args->device_list)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->device_list = NULL;
    }
    if (vcl_peek_array_size(dec)) {
        const size_t null_terminated_array_size = vcl_decode_array_size_unchecked(dec);
        args->options = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->options), null_terminated_array_size);
        if (!args->options) return;
        vcl_decode_char_array(dec, (char *)args->options, null_terminated_array_size);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->options = NULL;
    }
    vcl_decode_cl_uint(dec, &args->num_input_programs);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_input_programs);
        args->input_programs = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->input_programs), iter_count);
        if (!args->input_programs) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_program_lookup(dec, &((cl_program *)args->input_programs)[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->input_programs = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        vcl_cs_decoder_set_fatal(dec);
    } else {
        args->user_data = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->program = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->program));
        if (!args->program) return;
        vcl_decode_cl_program_temp(dec, args->program);
    } else {
        args->program = NULL;
        vcl_cs_decoder_set_fatal(dec);
    }
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_replace_clLinkProgramMESA_args_handle(struct vcl_command_clLinkProgramMESA *args)
{
    vcl_replace_cl_context_handle(&args->context);
    /* skip args->num_devices */
    if (args->device_list) {
       for (cl_uint i = 0; i < args->num_devices; i++)
            vcl_replace_cl_device_id_handle(&((cl_device_id *)args->device_list)[i]);
    }
    /* skip args->options */
    /* skip args->num_input_programs */
    if (args->input_programs) {
       for (cl_uint i = 0; i < args->num_input_programs; i++)
            vcl_replace_cl_program_handle(&((cl_program *)args->input_programs)[i]);
    }
    /* skip args->user_data */
    /* skip args->program */
}
#endif // CL_API_SUFFIX__VERSION_1_2

#ifdef CL_API_SUFFIX__VERSION_1_2
static inline void vcl_encode_clLinkProgramMESA_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clLinkProgramMESA *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clLinkProgramMESA_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->context */
    /* skip args->num_devices */
    /* skip args->device_list */
    /* skip args->options */
    /* skip args->num_input_programs */
    /* skip args->input_programs */
    if (vcl_encode_simple_pointer(enc, args->user_data))
        assert(false);
    if (vcl_encode_simple_pointer(enc, args->program))
        vcl_encode_cl_program(enc, args->program);
}
#endif // CL_API_SUFFIX__VERSION_1_2


static inline void vcl_dispatch_clReleaseProgram(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clReleaseProgram args;

    if (!ctx->dispatch_clReleaseProgram) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clReleaseProgram_args_temp(ctx->decoder, &args);
    if (!args.program) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clReleaseProgram(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clReleaseProgram returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clReleaseProgram_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clReleaseProgram");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clBuildProgram(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clBuildProgram args;

    if (!ctx->dispatch_clBuildProgram) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clBuildProgram_args_temp(ctx->decoder, &args);
    if (!args.program) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clBuildProgram(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clBuildProgram returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clBuildProgram_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clBuildProgram");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clCompileProgram(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2
    struct vcl_command_clCompileProgram args;

    if (!ctx->dispatch_clCompileProgram) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCompileProgram_args_temp(ctx->decoder, &args);
    if (!args.program) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCompileProgram(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCompileProgram returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCompileProgram_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2 not available for clCompileProgram");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2
}


static inline void vcl_dispatch_clGetProgramInfo(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clGetProgramInfo args;

    if (!ctx->dispatch_clGetProgramInfo) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetProgramInfo_args_temp(ctx->decoder, &args);
    if (!args.program) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetProgramInfo(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetProgramInfo returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetProgramInfo_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clGetProgramInfo");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clGetProgramBuildInfo(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clGetProgramBuildInfo args;

    if (!ctx->dispatch_clGetProgramBuildInfo) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetProgramBuildInfo_args_temp(ctx->decoder, &args);
    if (!args.program) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetProgramBuildInfo(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetProgramBuildInfo returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetProgramBuildInfo_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clGetProgramBuildInfo");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clCreateProgramWithSourceMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clCreateProgramWithSourceMESA args;

    if (!ctx->dispatch_clCreateProgramWithSourceMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateProgramWithSourceMESA_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateProgramWithSourceMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateProgramWithSourceMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateProgramWithSourceMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clCreateProgramWithSourceMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clCreateProgramWithBinaryMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clCreateProgramWithBinaryMESA args;

    if (!ctx->dispatch_clCreateProgramWithBinaryMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateProgramWithBinaryMESA_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateProgramWithBinaryMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateProgramWithBinaryMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateProgramWithBinaryMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clCreateProgramWithBinaryMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clCreateProgramWithILMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_2_1
    struct vcl_command_clCreateProgramWithILMESA args;

    if (!ctx->dispatch_clCreateProgramWithILMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clCreateProgramWithILMESA_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clCreateProgramWithILMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clCreateProgramWithILMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clCreateProgramWithILMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_2_1 not available for clCreateProgramWithILMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_2_1
}


static inline void vcl_dispatch_clLinkProgramMESA(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_2
    struct vcl_command_clLinkProgramMESA args;

    if (!ctx->dispatch_clLinkProgramMESA) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clLinkProgramMESA_args_temp(ctx->decoder, &args);
    if (!args.context) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clLinkProgramMESA(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clLinkProgramMESA returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clLinkProgramMESA_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_2 not available for clLinkProgramMESA");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_2
}

#pragma GCC diagnostic pop

#endif /* VCL_PROTOCOL_RENDERER_PROGRAM_H */
