/* This file is generated by vcl-protocol.  See vcl_protocol_renderer.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#ifndef VCL_PROTOCOL_RENDERER_PLATFORM_H
#define VCL_PROTOCOL_RENDERER_PLATFORM_H

#include "vcl_protocol_renderer_structs.h"

#pragma GCC diagnostic push
#if !defined(__clang__) && defined(__GNUC__) && __GNUC__ >= 12
#pragma GCC diagnostic ignored "-Wdangling-pointer"
#endif
#pragma GCC diagnostic ignored "-Wpointer-arith"
#pragma GCC diagnostic ignored "-Wunused-parameter"

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clGetPlatformIDs_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetPlatformIDs *args)
{
    vcl_decode_cl_uint(dec, &args->num_entries);
    if (vcl_peek_array_size(dec)) {
        const cl_uint iter_count = vcl_decode_array_size(dec, args->num_entries);
        args->platforms = vcl_cs_decoder_alloc_temp_array(dec, sizeof(*args->platforms), iter_count);
        if (!args->platforms) return;
        for (cl_uint i = 0; i < iter_count; i++)
            vcl_decode_cl_platform_id_temp(dec, &args->platforms[i]);
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->platforms = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->num_platforms = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->num_platforms));
        if (!args->num_platforms) return;
    } else {
        args->num_platforms = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clGetPlatformIDs_args_handle(struct vcl_command_clGetPlatformIDs *args)
{
    /* skip args->num_entries */
    /* skip args->platforms */
    /* skip args->num_platforms */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clGetPlatformIDs_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetPlatformIDs *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetPlatformIDs_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->num_entries */
    if (args->platforms) {
        vcl_encode_array_size(enc, args->num_entries);
        for (cl_uint i = 0; i < args->num_entries; i++)
            vcl_encode_cl_platform_id(enc, &args->platforms[i]);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->num_platforms))
        vcl_encode_cl_uint(enc, args->num_platforms);
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_decode_clGetPlatformInfo_args_temp(struct vcl_cs_decoder *dec, struct vcl_command_clGetPlatformInfo *args)
{
    vcl_decode_cl_platform_id_lookup(dec, &args->platform);
    vcl_decode_cl_platform_info(dec, &args->param_name);
    vcl_decode_size_t(dec, &args->param_value_size);
    if (vcl_peek_array_size(dec)) {
        const size_t array_size = vcl_decode_array_size(dec, args->param_value_size);
        args->param_value = vcl_cs_decoder_alloc_temp(dec, array_size);
        if (!args->param_value) return;
    } else {
        vcl_decode_array_size_unchecked(dec);
        args->param_value = NULL;
    }
    if (vcl_decode_simple_pointer(dec)) {
        args->param_value_size_ret = vcl_cs_decoder_alloc_temp(dec, sizeof(*args->param_value_size_ret));
        if (!args->param_value_size_ret) return;
    } else {
        args->param_value_size_ret = NULL;
    }
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_replace_clGetPlatformInfo_args_handle(struct vcl_command_clGetPlatformInfo *args)
{
    vcl_replace_cl_platform_id_handle(&args->platform);
    /* skip args->param_name */
    /* skip args->param_value_size */
    /* skip args->param_value */
    /* skip args->param_value_size_ret */
}
#endif // CL_API_SUFFIX__VERSION_1_0

#ifdef CL_API_SUFFIX__VERSION_1_0
static inline void vcl_encode_clGetPlatformInfo_reply(struct vcl_cs_encoder *enc, const struct vcl_command_clGetPlatformInfo *args)
{
    vcl_encode_cl_command_type_ext(enc, &(cl_command_type_ext){CL_COMMAND_TYPE_clGetPlatformInfo_EXT});

    vcl_encode_cl_int(enc, &args->ret);
    /* skip args->platform */
    /* skip args->param_name */
    /* skip args->param_value_size */
    if (args->param_value) {
        vcl_encode_array_size(enc, args->param_value_size);
        vcl_encode_blob_array(enc, args->param_value, args->param_value_size);
    } else {
        vcl_encode_array_size(enc, 0);
    }
    if (vcl_encode_simple_pointer(enc, args->param_value_size_ret))
        vcl_encode_size_t(enc, args->param_value_size_ret);
}
#endif // CL_API_SUFFIX__VERSION_1_0


static inline void vcl_dispatch_clGetPlatformIDs(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clGetPlatformIDs args;

    if (!ctx->dispatch_clGetPlatformIDs) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetPlatformIDs_args_temp(ctx->decoder, &args);

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetPlatformIDs(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetPlatformIDs returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetPlatformIDs_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clGetPlatformIDs");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}


static inline void vcl_dispatch_clGetPlatformInfo(struct vcl_dispatch_context *ctx, cl_command_flags_ext flags)
{
#ifdef CL_API_SUFFIX__VERSION_1_0
    struct vcl_command_clGetPlatformInfo args;

    if (!ctx->dispatch_clGetPlatformInfo) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    vcl_decode_clGetPlatformInfo_args_temp(ctx->decoder, &args);
    if (!args.platform) {
        vcl_cs_decoder_set_fatal(ctx->decoder);
        return;
    }

    if (!vcl_cs_decoder_get_fatal(ctx->decoder))
        ctx->dispatch_clGetPlatformInfo(ctx, &args);

#ifdef DEBUG
    if (!vcl_cs_decoder_get_fatal(ctx->decoder) && vcl_dispatch_should_log_result(args.ret))
        vcl_dispatch_debug_log(ctx, "clGetPlatformInfo returned %d", args.ret);
#endif

    if ((flags & CL_COMMAND_GENERATE_REPLY_BIT_EXT) && !vcl_cs_decoder_get_fatal(ctx->decoder))
        vcl_encode_clGetPlatformInfo_reply(ctx->encoder, &args);

    vcl_cs_decoder_reset_temp_pool(ctx->decoder);
#else
    vcl_dispatch_debug_log(ctx, "CL_API_SUFFIX__VERSION_1_0 not available for clGetPlatformInfo");
    vcl_cs_decoder_set_fatal(ctx->decoder);
#endif // CL_API_SUFFIX__VERSION_1_0
}

#pragma GCC diagnostic pop

#endif /* VCL_PROTOCOL_RENDERER_PLATFORM_H */
