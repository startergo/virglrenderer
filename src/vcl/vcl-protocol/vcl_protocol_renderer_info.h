/* This file is generated by vcl-protocol.  See vcl_protocol_renderer.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#ifndef VCL_PROTOCOL_RENDERER_INFO_H
#define VCL_PROTOCOL_RENDERER_INFO_H

#include "vcl_protocol_renderer_defines.h"

struct vcl_info_extension_table {
   union {
      bool enabled[2];
      struct {
         bool EXT_command_serialization;
         bool MESA_vcl_protocol;
      };
   };
};

#define VCL_INFO_EXTENSION_MAX_NUMBER (42)

struct vcl_info_extension {
   const char *name;
   uint32_t number;
   uint32_t spec_version;
};

/* sorted by extension names for bsearch */
static const uint32_t _vcl_info_extension_count = 2;
static const struct vcl_info_extension _vcl_info_extensions[2] = {
   { "CL_EXT_command_serialization", 42, 1 },
   { "CL_MESA_vcl_protocol", 42, 0 },
};

static inline uint32_t
vcl_info_wire_format_version(void)
{
    return 1;
}

static inline int
vcl_info_extension_compare(const void *name, const void *ext)
{
   return strcmp(name, ((const struct vcl_info_extension *)ext)->name);
}

static inline int32_t
vcl_info_extension_index(const char *name)
{
   const struct vcl_info_extension *ext = bsearch(name, _vcl_info_extensions,
      _vcl_info_extension_count, sizeof(*_vcl_info_extensions),
      vcl_info_extension_compare);
   return ext ? ext - _vcl_info_extensions : -1;
}

static inline const struct vcl_info_extension *
vcl_info_extension_get(int32_t index)
{
   assert(index >= 0 && (uint32_t)index < _vcl_info_extension_count);
   return &_vcl_info_extensions[index];
}

static inline void
vcl_info_extension_mask_init(uint32_t *out_mask)
{
   for (uint32_t i = 0; i < _vcl_info_extension_count; i++) {
       out_mask[_vcl_info_extensions[i].number / 32] |= 1 << (_vcl_info_extensions[i].number % 32);
   }
}

#endif /* VCL_PROTOCOL_RENDERER_INFO_H */
